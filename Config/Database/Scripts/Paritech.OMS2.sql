BEGIN TRANSACTION;
CREATE SCHEMA oms;

CREATE TABLE oms.Feed (
	 FeedID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,SourceID INTEGER NOT NULL
	,Code TEXT NOT NULL

	,CONSTRAINT PkFeed PRIMARY KEY (FeedID)
);

CREATE UNIQUE INDEX UqFeedSourceCode ON oms.Feed (SourceID, Code);

CREATE TABLE oms.Snapshot (
	 SnapshotID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,SourceID INTEGER NOT NULL
	,Type CHAR(2) NOT NULL
	,UpdateID BIGINT NOT NULL

	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL
	,ExpiredBy BIGINT

	,Data BYTEA NOT NULL

	,CONSTRAINT PkSnapshot PRIMARY KEY (SnapshotID)
);

-- Index for looking up active snapshots by the update they start from
CREATE UNIQUE INDEX UqSnapshotSourceTypeUpdate ON oms.Snapshot (SourceID, Type, UpdateID) WHERE (ExpiredBy IS NULL);

-- Index for looking up expired snapshots by the snapshot that expired them (so we can reactivate them when it's removed)
CREATE INDEX UqSnapshotSourceTypeExpiredBy ON oms.Snapshot (SourceID, Type, ExpiredBy) WHERE (ExpiredBy IS NOT NULL);

-- Index for looking up active snapshots by the date they were added
CREATE INDEX IxSnapshotSourceTypeDate ON oms.Snapshot (SourceID, Type, EventDate) WHERE (ExpiredBy IS NULL);

CREATE TABLE oms.Source (
	 SourceID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,Code VARCHAR(16) NOT NULL

	,CONSTRAINT PkSource PRIMARY KEY (SourceID)
);

CREATE UNIQUE INDEX UqSourceCode ON oms.Source (Code);

CREATE TABLE oms.Update (
	 SourceID INTEGER NOT NULL
	,UpdateID BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,FeedID INTEGER NOT NULL
	,FeedSequence BIGINT NOT NULL

	,Type CHAR(2) NOT NULL
	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL CONSTRAINT DfUpdateEventDate DEFAULT CURRENT_TIMESTAMP
	,AccountID TEXT

	,Data BYTEA NOT NULL
	,Metadata BYTEA NOT NULL

	,CONSTRAINT PkUpdate PRIMARY KEY (SourceID, UpdateID)
);

-- Should be used by UpdateGet when reading updates for a particular account
CREATE INDEX IxUpdateSourceAccountID ON oms.Update (SourceID, AccountID, UpdateID);

-- Should be used by UpdateGetForFeed
CREATE INDEX IxUpdateFeedSequence ON oms.Update (SourceID, FeedID, FeedSequence);

ALTER TABLE ONLY oms.Feed
	ADD CONSTRAINT FkFeedSource FOREIGN KEY (SourceID) REFERENCES oms.Source (SourceID);

ALTER TABLE ONLY oms.Snapshot
	ADD CONSTRAINT FkSnapshotSource FOREIGN KEY (SourceID) REFERENCES oms.Source (SourceID);

ALTER TABLE ONLY oms.Update
	ADD CONSTRAINT FkUpdateSource FOREIGN KEY (SourceID) REFERENCES oms.Source (SourceID);

CREATE OR REPLACE FUNCTION oms.FeedEnsureExists (_sourceId INTEGER, _code VARCHAR(16)) RETURNS INTEGER AS $$
DECLARE
	_FeedID BIGINT;
BEGIN
	LOOP
		SELECT	FE.FeedID INTO _FeedID
		FROM	oms.Feed FE
		WHERE	FE.SourceID = _sourceId AND FE.Code = _code;

		EXIT WHEN FOUND;

		INSERT INTO oms.Feed (SourceID, Code)
		VALUES      (_sourceId, _code)
		ON CONFLICT (SourceID, Code) DO NOTHING
		RETURNING FeedID INTO _FeedID;

		EXIT WHEN FOUND;
	END LOOP;

	RETURN _FeedID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.SnapshotCreate(_sourceId INTEGER, _type CHAR(2), _updateId BIGINT, _data BYTEA) RETURNS VOID AS $$
DECLARE
	_SnapshotID INTEGER;
BEGIN
	INSERT INTO oms.Snapshot (SourceID, Type, UpdateID, EventDate, Data)
		VALUES (_sourceId, _type, _updateId,  CURRENT_TIMESTAMP, _data)
		ON CONFLICT (SourceID, Type, UpdateID) WHERE (ExpiredBy IS NULL)
		DO UPDATE SET EventDate = CURRENT_TIMESTAMP, Data = _data
		RETURNING SnapshotID INTO _SnapshotID;

	-- Expire more recent snapshots. The hub may then perform a rollup
	UPDATE  oms.Snapshot
	SET     ExpiredBy = _SnapshotID
	WHERE	SourceID = _sourceId AND Type = _type AND UpdateID > _updateId AND ExpiredBy IS NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.SnapshotCreate(_sourceId INTEGER, _eventdate TIMESTAMP WITH TIME ZONE, _type CHAR(2), _updateId BIGINT, _data BYTEA) RETURNS VOID AS $$
DECLARE
	_SnapshotID INTEGER;
BEGIN
	INSERT INTO oms.Snapshot (SourceID, Type, UpdateID, EventDate, Data)
		VALUES (_sourceId, _type, _updateId,  _eventdate, _data)
		ON CONFLICT (SourceID, Type, UpdateID) WHERE (ExpiredBy IS NULL)
		DO UPDATE SET EventDate = _eventdate, Data = _data
		RETURNING SnapshotID INTO _SnapshotID;

	-- Expire more recent snapshots. The hub may then perform a rollup
	UPDATE  oms.Snapshot
	SET     ExpiredBy = _SnapshotID
	WHERE	SourceID = _sourceId AND Type = _type AND UpdateID > _updateId AND ExpiredBy IS NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.SnapshotDelete(_sourceId INTEGER, _type CHAR(2), _updateId BIGINT) RETURNS VOID AS $$
DECLARE
	_SnapshotID INTEGER;
BEGIN
	SELECT  SN.SnapshotID INTO _SnapshotID
	FROM    oms.Snapshot SN
	WHERE   SN.SourceID = _sourceId AND SN.Type = _type AND SN.UpdateID = _updateId;

	IF _SnapshotID IS NULL THEN
		RETURN;
	END IF;

	-- Remove this Snapshot, and any other Snapshots that were written afterwards
	DELETE
	FROM    oms.Snapshot
	WHERE   SnapshotID >= _SnapshotID AND SN.SourceID = _sourceId AND SN.Type = _type;

	-- Any previous Snapshots that were expired by the addition of this Snapshot should now be reactivated
	UPDATE  oms.Snapshot
	SET     ExpiredBy = NULL
	WHERE	SourceID = _sourceId AND Type = _type AND ExpiredBy = _SnapshotID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.SnapshotGet(_snapshotId INTEGER) RETURNS TABLE (
	 SnapshotID INTEGER
	,EventDate TIMESTAMP WITH TIME ZONE
	,Type CHAR(2)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  SS.SnapshotID, SS.EventDate, SS.Type, SS.Data
	FROM	oms.Snapshot SS
	WHERE   SS.SnapshotID = _snapshotId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.SnapshotGetBefore(_sourceId INTEGER, _type CHAR(2), _updateId BIGINT) RETURNS TABLE (
	 SnapshotID INTEGER
	,EventDate TIMESTAMP WITH TIME ZONE
	,Type CHAR(2)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  SS.SnapshotID, SS.EventDate, SS.Type, SS.Data
	FROM	oms.Snapshot SS
	WHERE   SS.SourceID = _sourceId AND SS.Type = _type AND SS.UpdateID <= _updateId AND ExpiredBy IS NULL
	ORDER BY SnapshotID DESC
	FETCH   FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.SnapshotGetLatest(_sourceId INTEGER, _type CHAR(2)) RETURNS TABLE (
	 SnapshotID INTEGER
	,EventDate TIMESTAMP WITH TIME ZONE
	,Type CHAR(2)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  SS.SnapshotID, SS.EventDate, SS.Type, SS.Data
	FROM	oms.Snapshot SS
	WHERE   SS.SourceID = _sourceId AND SS.Type = _type AND ExpiredBy IS NULL
	ORDER BY UpdateID DESC
	FETCH   FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.SnapshotGetRange(_sourceId INTEGER, _type CHAR(2), _fromDate TIMESTAMP WITH TIME ZONE, _toDate TIMESTAMP WITH TIME ZONE) RETURNS TABLE (
	 SnapshotID INTEGER
	,EventDate TIMESTAMP WITH TIME ZONE
	,Type CHAR(2)
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  SS.SnapshotID, SS.EventDate, SS.Type
	FROM	oms.Snapshot SS
	WHERE   SS.SourceID = _sourceId AND SS.Type = _type AND ExpiredBy IS NULL
	        AND (_fromDate IS NULL OR SS.EventDate >= _fromDate)
	        AND (_toDate IS NULL OR SS.EventDate <= _toDate)
	ORDER BY EventDate, UpdateID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.SourceEnsureExists (_code VARCHAR(16)) RETURNS INTEGER AS $$
DECLARE
	_SourceID BIGINT;
BEGIN
	LOOP
		SELECT	SO.SourceID INTO _SourceID
		FROM	oms.Source SO
		WHERE	SO.Code = _code;

		EXIT WHEN FOUND;
		
		INSERT INTO oms.Source (Code)
		VALUES      (_code)
		ON CONFLICT DO NOTHING
		RETURNING SourceID INTO _SourceID;

		EXIT WHEN FOUND;
	END LOOP;

	RETURN _SourceID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.UpdateCreate(_sourceId INTEGER, _feedId INTEGER, _feedSequence BIGINT, _type CHAR(2), _data BYTEA, _metadata BYTEA) RETURNS BIGINT AS $$
DECLARE
	_updateID BIGINT;
BEGIN
	INSERT INTO oms.Update (SourceID, FeedID, FeedSequence, Type, Data, Metadata)
		VALUES (_sourceId, _feedId, _feedSequence, _type, _data, _metadata)
		RETURNING UpdateID INTO _updateID;

	RETURN _updateID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.UpdateCreate(_sourceId INTEGER, _feedId INTEGER, _feedSequence BIGINT, _eventdate TIMESTAMP WITH TIME ZONE, _type CHAR(2), _data BYTEA, _metadata BYTEA) RETURNS BIGINT AS $$
DECLARE
	_updateID BIGINT;
BEGIN
	-- This function is specifically for imports and migrations. UpdateGetBefore relies on EventDate increasing in line with UpdateID.
	-- For this reason, realtime events should never be written with a given date, because if the dates come from independent systems, the ordering can break.
	-- When using this function, callers must ensure the dates supplied are always increasing.
	INSERT INTO oms.Update (SourceID, FeedID, FeedSequence, EventDate, Type, Data, Metadata)
		VALUES (_sourceId, _feedId, _feedSequence, _eventdate, _type, _data, _metadata)
		RETURNING UpdateID INTO _updateID;

	RETURN _updateID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.UpdateGetAfter(_sourceId INTEGER, _fromUpdate BIGINT, _count INTEGER) RETURNS TABLE (
	 UpdateID BIGINT

	,Type CHAR(2)
	,EventDate TIMESTAMP WITH TIME ZONE
	,AccountID TEXT

	,Data BYTEA
	,Metadata BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  UD.UpdateID, UD.Type, UD.EventDate, UD.AccountID, UD.Data, UD.Metadata
	FROM	oms.Update UD
	WHERE   UD.SourceID = _sourceId AND UD.UpdateID > _fromUpdate
	ORDER BY UpdateID ASC
	FETCH   FIRST (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Used by the Hub to replay events after a Snapshot

CREATE OR REPLACE FUNCTION oms.UpdateGetBefore(_sourceId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS TABLE (
	 UpdateID BIGINT

	,EventDate TIMESTAMP WITH TIME ZONE
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  UD.UpdateID, UD.EventDate
	FROM	oms.Update UD
	WHERE   UD.SourceID = _sourceId AND UD.EventDate < _timestamp
	ORDER BY UpdateID DESC
	FETCH   FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Used by the Hub to determine the Update ID at a point in time (for backdating Snapshots)

CREATE OR REPLACE FUNCTION oms.UpdateGetFeedAsAt(_sourceId INTEGER, _feedId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  MAX(UD.FeedSequence)
		FROM	oms.Update UD
		WHERE   UD.SourceID = _sourceId AND UD.FeedID = _feedId AND UD.EventDate < _timestamp
	);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.UpdateGetForFeedAfter(_sourceId INTEGER, _feedId INTEGER, _sequenceNumber BIGINT) RETURNS TABLE (
	 UpdateID BIGINT
	,FeedSequence BIGINT

	,Type CHAR(2)
	,EventDate TIMESTAMP WITH TIME ZONE

	,Data BYTEA
	,Metadata BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  UD.UpdateID, UD.FeedSequence, UD.Type, UD.EventDate, UD.Data, UD.Metadata
	FROM	oms.Update UD
	WHERE   UD.SourceID = _sourceId
	        AND UD.FeedID = _feedId AND UD.FeedSequence > _sequenceNumber
	ORDER BY UpdateID ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.UpdateGetForFeedRange(_sourceId INTEGER, _feedId INTEGER, _fromSequence BIGINT, _toSequence BIGINT, _count INT) RETURNS TABLE (
	 UpdateID BIGINT
	,FeedSequence BIGINT

	,Type CHAR(2)
	,EventDate TIMESTAMP WITH TIME ZONE

	,Data BYTEA
	,Metadata BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  UD.UpdateID, UD.FeedSequence, UD.Type, UD.EventDate, UD.Data, UD.Metadata
	FROM    oms.Update UD
	WHERE   UD.SourceID = _sourceId
	        AND UD.FeedID = _feedId AND UD.FeedSequence > _fromSequence
	        AND (_toSequence IS NULL OR UD.FeedSequence <= _toSequence)
	ORDER BY UpdateID ASC
	FETCH   FIRST (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION oms.UpdateGetLatestForFeed(_sourceId INTEGER, _feedId INTEGER) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  UD.FeedSequence
		FROM	oms.Update UD
		WHERE   UD.SourceID = _sourceId AND UD.FeedID = _feedId
		ORDER BY UpdateID DESC
		FETCH   FIRST 1 ROW ONLY
	);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Used by adapters to determine the most recently written Event ID written for a particular feed

CREATE OR REPLACE FUNCTION oms.UpdateGetRange(_sourceId INTEGER, _fromUpdate BIGINT, _toUpdate BIGINT, _count INTEGER) RETURNS TABLE (
	 UpdateID BIGINT

	,Type CHAR(2)
	,EventDate TIMESTAMP WITH TIME ZONE
	,AccountID TEXT

	,Data BYTEA
	,Metadata BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  UD.UpdateID, UD.Type, UD.EventDate, UD.AccountID, UD.Data, UD.Metadata
	FROM    oms.Update UD
	WHERE   UD.SourceID = _sourceId AND UD.UpdateID > _fromUpdate
	        AND (_toUpdate IS NULL OR UD.UpdateID <= _toUpdate)
	ORDER BY UpdateID ASC
	FETCH   FIRST (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Used by the hub to respond to queries over a range

CREATE OR REPLACE FUNCTION oms.UpdateReplace(_updateId BIGINT, _type CHAR(2), _data BYTEA, _metadata BYTEA) RETURNS VOID AS $$
BEGIN
	UPDATE  oms.Update
	SET     Type = _type, Data = _data, Metadata = _metadata
	WHERE   UpdateID = _updateId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMIT TRANSACTION;
