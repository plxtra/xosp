BEGIN TRANSACTION;
CREATE SCHEMA IF NOT EXISTS fix;

CREATE SCHEMA IF NOT EXISTS phist;

CREATE SCHEMA IF NOT EXISTS prodigy;

DROP SCHEMA IF EXISTS public;

CREATE TABLE IF NOT EXISTS fix.Account(
	 AccountID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,EntityID INTEGER NOT NULL
	,Name VARCHAR NOT NULL
	,ExternalID VARCHAR NOT NULL
	,Description VARCHAR
	
	,Status CHAR(2) NOT NULL CONSTRAINT DfAccountStatus DEFAULT 'AC'
	,Permissions VARCHAR NOT NULL CONSTRAINT DfAccountPermissions DEFAULT 'F'

	,CONSTRAINT PkAccount PRIMARY KEY (AccountID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqAccountName ON fix.Account (Name) WHERE Status != 'DE';

CREATE TABLE IF NOT EXISTS fix.AccountEntity (
	 AccountID INTEGER NOT NULL
	,EntityID INTEGER NOT NULL

	,CONSTRAINT PkAccountEntity PRIMARY KEY (AccountID, EntityID)
);

CREATE TABLE IF NOT EXISTS fix.Entity (
	 EntityID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,Code VARCHAR(16) NOT NULL
	,Type CHAR(2) NOT NULL
	,Name TEXT NOT NULL
	,IsDeleted BOOLEAN CONSTRAINT DfEntityIsDeleted DEFAULT FALSE

	,CONSTRAINT PkEntity PRIMARY KEY (EntityID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqEntityCodeDeleted ON fix.Entity (Code) WHERE IsDeleted = FALSE;

CREATE TABLE IF NOT EXISTS fix.Login (
	 LoginID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,SessionID INTEGER NOT NULL
	,AccountID INTEGER NOT NULL

	,LogonAt TIMESTAMP WITH TIME ZONE NOT NULL
	,LogoffAt TIMESTAMP WITH TIME ZONE
	,LogoffReason TEXT

	,SourceIp INET NOT NULL
	,SourcePort INTEGER NOT NULL
	,TargetIp INET NOT NULL
	,TargetPort INTEGER NOT NULL

	,CONSTRAINT PkLogin PRIMARY KEY (LoginID)
);

CREATE INDEX IF NOT EXISTS IxLoginAccount ON fix.Login (AccountID, LoginID);
CREATE INDEX IF NOT EXISTS IxLoginSession ON fix.Login (SessionID, LoginID);

CREATE TABLE IF NOT EXISTS fix.Message (
	 SessionID INTEGER NOT NULL
	,IsOutgoing BOOLEAN NOT NULL
	,SequenceNumber BIGINT NOT NULL

	,SentAt TIMESTAMP WITH TIME ZONE NOT NULL CONSTRAINT DfMessageSentAt DEFAULT CURRENT_TIMESTAMP
	,Data BYTEA NOT NULL
	,Context BYTEA

	,CONSTRAINT PkMessage PRIMARY KEY (SessionID, IsOutgoing, SequenceNumber)
);

CREATE TABLE IF NOT EXISTS fix.Session (
	 SessionID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,BeginString VARCHAR(32) NOT NULL
	,Sender VARCHAR(32) NOT NULL
	,Target VARCHAR(32) NOT NULL
	,Qualifiers VARCHAR(32)
	,ApplVerID VARCHAR(16)
	
	,AccountID INTEGER NOT NULL

	,IsTransient BOOLEAN NOT NULL
	,ResetOnNextLogin BOOLEAN NOT NULL CONSTRAINT DfSessionReset DEFAULT FALSE
	,StartedDate TIMESTAMP WITH TIME ZONE

	,Data BYTEA NOT NULL CONSTRAINT DfSessionData DEFAULT '{}'::BYTEA

	,CONSTRAINT PkSession PRIMARY KEY (SessionID)
	,CONSTRAINT UqSessionAccount UNIQUE NULLS NOT DISTINCT (BeginString, Sender, Target, Qualifiers, ApplVerID)
);

CREATE TABLE IF NOT EXISTS fix.SessionEntity (
	 SessionID INTEGER NOT NULL
	,EntityID INTEGER NOT NULL

	,CanTrade BOOLEAN NOT NULL

	,CONSTRAINT PkSessionEntity PRIMARY KEY (SessionID, EntityID)
);

CREATE TABLE IF NOT EXISTS fix.SessionMarket (
	 SessionID INTEGER NOT NULL
	,MarketCode VARCHAR(16) NOT NULL

	,CanTrade BOOLEAN NOT NULL

	,CONSTRAINT PkSessionMarket PRIMARY KEY (SessionID, MarketCode)
);

CREATE TABLE IF NOT EXISTS fix.SessionSnapshot (
	 SessionID INTEGER NOT NULL
	,MarketCode VARCHAR(16) NOT NULL

	,SequenceNumber BIGINT NOT NULL -- The last outgoing sequence number when this was created
	,Data BYTEA NOT NULL -- The raw snapshot data

	,CONSTRAINT PkSessionSnapshot PRIMARY KEY (SessionID, MarketCode)
	);

CREATE TABLE IF NOT EXISTS fix.Subscription (
	 SessionID INTEGER NOT NULL
	,RequestID VARCHAR(32) NOT NULL -- User-assigned Request Identifier

	,SubscriptionType CHAR(2) NOT NULL -- MA or SE
	,Data BYTEA NOT NULL

	,CONSTRAINT PkSubscription PRIMARY KEY (SessionID, RequestID)
	);

CREATE TABLE IF NOT EXISTS phist.DepthChange (
	 SymbolVersionID BIGINT NOT NULL
	,SequenceNumber BIGINT NOT NULL

	,OrderID BIGINT NOT NULL -- Internal Order ID, maps to phist.Order.OrderID

	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL
	,ChangeType CHAR(1) NOT NULL -- [A]dd, [U]pdate, [R]emove

	,Price DECIMAL
	,Quantity BIGINT
	,Position BIGINT
	,Market VARCHAR(16)

	,CONSTRAINT PkDepthChange PRIMARY KEY (SymbolVersionID, SequenceNumber, OrderID) -- Can be multiple orders changed in one operation
);

-- CREATE INDEX IxDepthChangeOrderEvent on phist.DepthChange (SymbolVersionID, OrderID, SequenceNumber)

CREATE TABLE IF NOT EXISTS phist.Entity (
	 EntityID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,Code VARCHAR(16) NOT NULL
	,IsDeleted BOOLEAN CONSTRAINT DfEntityIsDeleted DEFAULT FALSE

	,CONSTRAINT PkEntity PRIMARY KEY (EntityID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqEntityCodeDeleted ON phist.Entity (Code) WHERE IsDeleted = FALSE;

CREATE TABLE IF NOT EXISTS phist.Market (
	 MarketID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,Code VARCHAR(16) NOT NULL
	,IsDeleted BOOLEAN CONSTRAINT DfMarketIsDeleted DEFAULT FALSE

	,CONSTRAINT PkMarket PRIMARY KEY (MarketID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqMarketCodeDeleted ON phist.Market (Code) WHERE IsDeleted = FALSE;

CREATE TABLE IF NOT EXISTS phist.News (
	 MarketID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL -- Identifier of the market when the announcement was placed or updated

	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL
	,NewsID BIGINT NOT NULL -- Identifier of the announcement. May be duplicated if the announcement is updated
	,Title TEXT NOT NULL

	,Priority SMALLINT NOT NULL

	,NewsBody BIGINT

	,CONSTRAINT PkNews PRIMARY KEY (MarketID, SequenceNumber)
);

CREATE INDEX IxNewsMarketEventDate ON phist.News (MarketID, EventDate);

CREATE TABLE IF NOT EXISTS phist.NewsBody (
	 NewsBodyID BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,Created TIMESTAMP WITH TIME ZONE NOT NULL

	,FileName TEXT NOT NULL
	,Reference VARCHAR(64) NOT NULL -- The reference generated by the News Body Store
	,MimeType TEXT NOT NULL
	,Hash BYTEA NOT NULL
	,Length BIGINT NOT NULL

	,Comments TEXT

	,CONSTRAINT PkNewsBody PRIMARY KEY (NewsBodyID)
	,CONSTRAINT UqNewsBodyReference UNIQUE (Reference)
);

CREATE TABLE IF NOT EXISTS phist.NewsSymbol (
	 MarketID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL
	,SymbolVersionID BIGINT NOT NULL

	,CONSTRAINT PkNewsSymbol PRIMARY KEY (MarketID, SequenceNumber, SymbolVersionID)
	);

CREATE INDEX IF NOT EXISTS IxNewsSymbolSymbolMarket ON phist.NewsSymbol (SymbolVersionID, MarketID, SequenceNumber);

CREATE TABLE IF NOT EXISTS phist.Order (
	 OrderID BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL
	,SymbolID BIGINT NOT NULL
	,DepthOrderID BIGINT NOT NULL -- Market-assigned Order ID

	,OwnerID BIGINT NOT NULL

	,Side CHAR(1) NOT NULL -- [B]id, [A]sk
	,ClientContext TEXT

	,CONSTRAINT PkOrder PRIMARY KEY (OrderID)
	,CONSTRAINT UqOrderSymbolDepth UNIQUE (SymbolID, DepthOrderID)
);

--CREATE INDEX IxOrderOwnerRef ON phist.Order (OwnerID, SymbolID, DepthOrderID);

CREATE TABLE IF NOT EXISTS phist.OrderAudit (
	 OrderID BIGINT NOT NULL
	,SequenceNumber BIGINT NOT NULL -- For executions combine with phist.Order.SymbolID, maps to phist.Trade.SymbolID+SequenceNumber
	,Version BIGINT NOT NULL

	,EntityID INTEGER NOT NULL
	,OwnerID BIGINT NOT NULL
	,SymbolVersionID BIGINT NOT NULL

	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL
	,ExecType CHAR(1) NOT NULL -- [S]tatus, [T]rade
	,Status CHAR(1) NOT NULL -- [X]-Cancelled, [E]xpired, [F]illed, [O]nMarket, [P]artialFill

	,Created TIMESTAMP WITH TIME ZONE NOT NULL
	,Updated TIMESTAMP WITH TIME ZONE NOT NULL

	,Price DECIMAL
	,Quantity BIGINT
	,MinQuantity BIGINT
	,Market VARCHAR(16)

	,Currency VARCHAR(8)
	,TimeInForce CHAR(2) -- [F]ill or [K]ill, [I]mmediate or [C]ancel, [G]ood till [D]ate, [G]ood till [C]ancel
	,ExecInst TEXT
	,ExpiryDate TIMESTAMP WITH TIME ZONE

	,ExecutedQuantity BIGINT
	,ExecutedValue DECIMAL

	,ContraOrderID BIGINT

	,CONSTRAINT PkOrderAudit PRIMARY KEY (OrderID, SequenceNumber)
);

-- Indexes to make searching by Event ID range fast on a per-entity and per-owner bases
CREATE INDEX IF NOT EXISTS IxOrderAuditEntityEvent ON phist.OrderAudit (EntityID, OrderID, SequenceNumber);

CREATE INDEX IF NOT EXISTS IxOrderAuditOwnerEvent ON phist.OrderAudit (OwnerID, OrderID, SequenceNumber);

CREATE TABLE IF NOT EXISTS phist.Owner (
	 OwnerID BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,EntityID INTEGER NOT NULL
	,Code TEXT NOT NULL

	,CONSTRAINT PkOwner PRIMARY KEY (OwnerID)
	,CONSTRAINT UqOwnerEntityCode UNIQUE (EntityID, Code)
);

CREATE TABLE IF NOT EXISTS phist.Symbol (
	 SymbolID BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,MarketID INTEGER NOT NULL
	,MarketSymbolID BIGINT NOT NULL
	
	,IsDeleted BOOLEAN CONSTRAINT DfSymbolIsDeleted DEFAULT FALSE

	,CONSTRAINT PkSymbol PRIMARY KEY (SymbolID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqSymbolMarketSymbol ON phist.Symbol (MarketID, MarketSymbolID);

CREATE TABLE IF NOT EXISTS phist.SymbolVersion (
	 SymbolVersionID BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL
	,SymbolID BIGINT NOT NULL

	,StartSequenceNumber BIGINT NOT NULL
	,EndSequenceNumber BIGINT
	
	,Code VARCHAR(16) NOT NULL

	,CONSTRAINT PkSymbolVersion PRIMARY KEY (SymbolVersionID)
);

CREATE INDEX IF NOT EXISTS UqSymbolVersionSymbol ON phist.SymbolVersion (SymbolID, StartSequenceNumber);

CREATE UNIQUE INDEX IF NOT EXISTS UqSymbolVersionSymbolEndSequence ON phist.SymbolVersion (SymbolID) WHERE EndSequenceNumber IS NULL;

CREATE TABLE IF NOT EXISTS phist.Trade (
	 SymbolVersionID BIGINT NOT NULL
	,SequenceNumber BIGINT NOT NULL -- Combine SymbolVersionID and BuyOrderID/SellOrderID to get OrderID, then maps to phist.OrderAudit.OrderID+SequenceNumber (only for new trades)

	,TradeID BIGINT NOT NULL -- May differ from Sequence Number depending on the market model, and whether this is a cancellation
	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL
	,Price DECIMAL
	,Quantity BIGINT
	,Aggressor CHAR(1) -- [B]id, [A]sk, NULL
	,Market VARCHAR(16)

	,Statistics VARCHAR(8)
	,Status CHAR(1) NOT NULL -- [T]rade, [C]orrection, [X]Cancel

	,BuyOrderID BIGINT NOT NULL -- Combine with SymbolVersionID, maps to phist.Order.SymbolID+DepthOrderID
	,SellOrderID BIGINT NOT NULL -- Combine with SymbolVersionID, maps to phist.Order.SymbolID+DepthOrderID

	,CONSTRAINT PkTrade PRIMARY KEY (SymbolVersionID, SequenceNumber)
);

CREATE INDEX IF NOT EXISTS IxTradeSymbolEventDate ON phist.Trade (SymbolVersionID, EventDate);

CREATE TABLE IF NOT EXISTS prodigy.Market (
	 MarketID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,Code VARCHAR(16) NOT NULL
	,CreatedDate TIMESTAMP WITH TIME ZONE CONSTRAINT DfMarketCreatedDate DEFAULT CURRENT_TIMESTAMP
	,IsDeleted BOOLEAN CONSTRAINT DfMarketIsDeleted DEFAULT FALSE
	,Comments TEXT

	,CONSTRAINT PkMarket PRIMARY KEY (MarketID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqMarketCodeDeleted ON prodigy.Market (Code) WHERE IsDeleted = FALSE;

CREATE TABLE IF NOT EXISTS prodigy.MarketCheckpoint (
	 MarketCheckpointID BIGINT GENERATED BY DEFAULT AS IDENTITY
	,MarketID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL -- The Sequence Number of the most recent Market Snapshot before the oldest Security Snapshot as at the Checkpoint
	
	,CheckpointDate TIMESTAMP WITH TIME ZONE NOT NULL CONSTRAINT DfCheckpointSnapshotDate DEFAULT CURRENT_TIMESTAMP

	,CONSTRAINT PkMarketCheckpoint PRIMARY KEY (MarketCheckpointID)
	,CONSTRAINT UqMarketCheckpointMarketDate UNIQUE (MarketID, CheckpointDate)
);

CREATE TABLE IF NOT EXISTS prodigy.MarketCheckpointSecurity (
	 MarketCheckpointID BIGINT NOT NULL
	,SymbolID INTEGER NOT NULL
	
	,SequenceNumber BIGINT NOT NULL -- The Sequence Number of the most recent Snapshot for this Security as at the Checkpoint

	,CONSTRAINT PkMarketCheckpointSecurity PRIMARY KEY (MarketCheckpointID, SymbolID)
);

CREATE TABLE IF NOT EXISTS prodigy.MarketEvent (
	 MarketID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL
	
	,EventType VARCHAR(32) NOT NULL
	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL CONSTRAINT DfMarketEventDate DEFAULT CURRENT_TIMESTAMP
	,Data BYTEA NOT NULL

	,CONSTRAINT PkMarketEvent PRIMARY KEY (MarketID, SequenceNumber)
);

CREATE TABLE IF NOT EXISTS prodigy.MarketSetup (
	 MarketID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL

	,SetupDate TIMESTAMP WITH TIME ZONE CONSTRAINT DfMarketSetupDate DEFAULT CURRENT_TIMESTAMP
	,Setup BYTEA NOT NULL -- System setup - types and assemblies
	,Config BYTEA NOT NULL -- Core market configuration

	,CONSTRAINT PkMarketSetup PRIMARY KEY (MarketID, SequenceNumber)
);

CREATE TABLE IF NOT EXISTS prodigy.MarketSnapshot (
	 MarketID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL
	
	,SnapshotDate TIMESTAMP WITH TIME ZONE NOT NULL
	,Data BYTEA NOT NULL

	,CONSTRAINT PkMarketSnapshot PRIMARY KEY (MarketID, SequenceNumber)
);

CREATE TABLE IF NOT EXISTS prodigy.Operation (
	 MessageKey TEXT NOT NULL
	,MessageID UUID NOT NULL
	,ProcessedDate TIMESTAMP WITH TIME ZONE NOT NULL

	,CONSTRAINT PkOperation PRIMARY KEY (MessageID)
	);

CREATE INDEX IF NOT EXISTS IxOperationProcessedDate ON prodigy.Operation (MessageKey ASC, ProcessedDate ASC);

CREATE TABLE IF NOT EXISTS prodigy.SecurityEvent (
	 SymbolID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL
	
	,MarketSequenceNumber BIGINT NOT NULL
	,EventType VARCHAR(32) NOT NULL
	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL CONSTRAINT DfSecurityEventDate DEFAULT CURRENT_TIMESTAMP

	,Data BYTEA NOT NULL

	,CONSTRAINT PkSecurityEvent PRIMARY KEY (SymbolID, SequenceNumber)
);

CREATE INDEX IF NOT EXISTS IxSecurityEventSymbolSequenceNumber ON prodigy.SecurityEvent (MarketSequenceNumber, SequenceNumber);

CREATE TABLE IF NOT EXISTS prodigy.SecuritySnapshot (
	 SymbolID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL
	
	,MarketSequenceNumber BIGINT NOT NULL
	,SnapshotDate TIMESTAMP WITH TIME ZONE NOT NULL
	,Data BYTEA NOT NULL

	,CONSTRAINT PkSecuritySnapshot PRIMARY KEY (SymbolID, SequenceNumber)
);

CREATE TABLE IF NOT EXISTS prodigy.Symbol (
	 SymbolID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL -- Database-specific identifier, should not be used outside the Repository adapter

	,MarketID INTEGER NOT NULL
	,MarketSymbolID INTEGER NOT NULL -- Market-specific identifier, should correspond to ISymbolModel.SymbolID
	,Code VARCHAR(16) NOT NULL
	,Comments TEXT
	
	,DeletedAt BIGINT NULL -- Market Sequence Number this Symbol was deleted at

	,CONSTRAINT PkSymbol PRIMARY KEY (SymbolID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqSymbolMarketIDCodeDeleted ON prodigy.Symbol (MarketID, Code, DeletedAt);
CREATE UNIQUE INDEX IF NOT EXISTS UqSymbolMarketIDSymbolID ON prodigy.Symbol (MarketID, MarketSymbolID);

CREATE TABLE IF NOT EXISTS prodigy.SymbolSetup (
	 SymbolID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL -- Market Sequence Number

	,SetupDate TIMESTAMP WITH TIME ZONE NOT NULL CONSTRAINT DfSymbolSetupDate DEFAULT CURRENT_TIMESTAMP
	,Data BYTEA NOT NULL

	,CONSTRAINT PkSymbolSetup PRIMARY KEY (SymbolID, SequenceNumber)
);

ALTER TABLE ONLY fix.Account
	ADD CONSTRAINT FkAccountEntity FOREIGN KEY (EntityID) REFERENCES fix.Entity (EntityID);

ALTER TABLE ONLY fix.AccountEntity
	ADD CONSTRAINT FkAccountEntityAccount FOREIGN KEY (AccountID) REFERENCES fix.Account (AccountID);

ALTER TABLE ONLY fix.AccountEntity
	ADD CONSTRAINT FkAccountEntityEntity FOREIGN KEY (EntityID) REFERENCES fix.Entity (EntityID);

ALTER TABLE ONLY fix.Login
	ADD CONSTRAINT FkLoginAccount FOREIGN KEY (AccountID) REFERENCES fix.Account (AccountID);

ALTER TABLE ONLY fix.Login
	ADD CONSTRAINT FkLoginFixSession FOREIGN KEY (SessionID) REFERENCES fix.Session (SessionID);

ALTER TABLE ONLY fix.Message
	ADD CONSTRAINT FkMessageFixSession FOREIGN KEY (SessionID) REFERENCES fix.Session (SessionID);

ALTER TABLE ONLY fix.Session
	ADD CONSTRAINT FkSessionAccount FOREIGN KEY (AccountID) REFERENCES fix.Account (AccountID);

ALTER TABLE ONLY fix.SessionEntity
	ADD CONSTRAINT FkSessionEntityEntity FOREIGN KEY (EntityID) REFERENCES fix.Entity (EntityID);

ALTER TABLE ONLY fix.SessionEntity
	ADD CONSTRAINT FkSessionEntityFixSession FOREIGN KEY (SessionID) REFERENCES fix.Session (SessionID);

ALTER TABLE ONLY fix.SessionMarket
	ADD CONSTRAINT FkSessionMarketFixSession FOREIGN KEY (SessionID) REFERENCES fix.Session (SessionID);

ALTER TABLE ONLY fix.SessionSnapshot
	ADD CONSTRAINT FkSessionSnapshotSession FOREIGN KEY (SessionID) REFERENCES fix.Session (SessionID);

ALTER TABLE ONLY fix.Subscription
	ADD CONSTRAINT FkSubscriptionFixSession FOREIGN KEY (SessionID) REFERENCES fix.Session (SessionID);

ALTER TABLE ONLY phist.DepthChange
	ADD CONSTRAINT FkDepthChangeOrder FOREIGN KEY (OrderID) REFERENCES phist.Order (OrderID);

ALTER TABLE ONLY phist.DepthChange
	ADD CONSTRAINT FkDepthChangeSymbolVersion FOREIGN KEY (SymbolVersionID) REFERENCES phist.SymbolVersion (SymbolVersionID);

ALTER TABLE ONLY phist.News
	ADD CONSTRAINT FkNewsMarket FOREIGN KEY (MarketID) REFERENCES phist.Market (MarketID);

ALTER TABLE ONLY phist.NewsSymbol
	ADD CONSTRAINT FkNewsSymbolNews FOREIGN KEY (MarketID, SequenceNumber) REFERENCES phist.News (MarketID, SequenceNumber);

ALTER TABLE ONLY phist.NewsSymbol
	ADD CONSTRAINT FkNewsSymbolSymbolVersion FOREIGN KEY (SymbolVersionID) REFERENCES phist.SymbolVersion (SymbolVersionID);

ALTER TABLE ONLY phist.OrderAudit
	ADD CONSTRAINT FkOrderAuditContraOrder FOREIGN KEY (ContraOrderID) REFERENCES phist.Order (OrderID);

ALTER TABLE ONLY phist.OrderAudit
	ADD CONSTRAINT FkOrderAuditEntity FOREIGN KEY (EntityID) REFERENCES phist.Entity (EntityID);

ALTER TABLE ONLY phist.OrderAudit
	ADD CONSTRAINT FkOrderAuditOrder FOREIGN KEY (OrderID) REFERENCES phist.Order (OrderID);

ALTER TABLE ONLY phist.OrderAudit
	ADD CONSTRAINT FkOrderAuditOwner FOREIGN KEY (OwnerID) REFERENCES phist.Owner (OwnerID);

ALTER TABLE ONLY phist.OrderAudit
	ADD CONSTRAINT FkOrderAuditSymbolVersion FOREIGN KEY (SymbolVersionID) REFERENCES phist.SymbolVersion (SymbolVersionID);

ALTER TABLE ONLY phist.Order
	ADD CONSTRAINT FkOrderSymbol FOREIGN KEY (SymbolID) REFERENCES phist.Symbol (SymbolID);

ALTER TABLE ONLY phist.Owner
	ADD CONSTRAINT FkOwnerEntity FOREIGN KEY (EntityID) REFERENCES phist.Entity (EntityID);

ALTER TABLE ONLY phist.Symbol
	ADD CONSTRAINT FkSymbolMarket FOREIGN KEY (MarketID) REFERENCES phist.Market (MarketID);

ALTER TABLE ONLY phist.SymbolVersion
	ADD CONSTRAINT FkSymbolVersionSymbol FOREIGN KEY (SymbolID) REFERENCES phist.Symbol (SymbolID);

ALTER TABLE ONLY phist.Trade
	ADD CONSTRAINT FkTradeBuyOrder FOREIGN KEY (BuyOrderID) REFERENCES phist.Order (OrderID);

ALTER TABLE ONLY phist.Trade
	ADD CONSTRAINT FkTradeSellOrder FOREIGN KEY (SellOrderID) REFERENCES phist.Order (OrderID);

ALTER TABLE ONLY phist.Trade
	ADD CONSTRAINT FkTradeSymbolVersion FOREIGN KEY (SymbolVersionID) REFERENCES phist.SymbolVersion (SymbolVersionID);

ALTER TABLE ONLY prodigy.MarketCheckpoint
	ADD CONSTRAINT FkMarketCheckpointMarket FOREIGN KEY (MarketID) REFERENCES prodigy.Market (MarketID);

ALTER TABLE ONLY prodigy.MarketCheckpointSecurity
	ADD CONSTRAINT FkMarketCheckpointSecurityMarketCheckpoint FOREIGN KEY (MarketCheckpointID) REFERENCES prodigy.MarketCheckpoint (MarketCheckpointID);

ALTER TABLE ONLY prodigy.MarketCheckpointSecurity
	ADD CONSTRAINT FkMarketCheckpointSecuritySymbol FOREIGN KEY (SymbolID) REFERENCES prodigy.Symbol (SymbolID);

ALTER TABLE ONLY prodigy.MarketEvent
	ADD CONSTRAINT FkMarketEventMarket FOREIGN KEY (MarketID) REFERENCES prodigy.Market (MarketID);

ALTER TABLE ONLY prodigy.MarketSetup
	ADD CONSTRAINT FkMarketSetupMarket FOREIGN KEY (MarketID) REFERENCES prodigy.Market (MarketID);

ALTER TABLE ONLY prodigy.MarketSnapshot
	ADD CONSTRAINT FkMarketSnapshotMarket FOREIGN KEY (MarketID) REFERENCES prodigy.Market (MarketID);

ALTER TABLE ONLY prodigy.SecurityEvent
	ADD CONSTRAINT FkSecurityEventSymbol FOREIGN KEY (SymbolID) REFERENCES prodigy.Symbol (SymbolID);

ALTER TABLE ONLY prodigy.SecuritySnapshot
	ADD CONSTRAINT FkSecuritySnapshotSymbol FOREIGN KEY (SymbolID) REFERENCES prodigy.Symbol (SymbolID);

ALTER TABLE ONLY prodigy.Symbol
	ADD CONSTRAINT FkSymbolMarket FOREIGN KEY (MarketID) REFERENCES prodigy.Market (MarketID);

ALTER TABLE ONLY prodigy.SymbolSetup
	ADD CONSTRAINT FkSymbolSetupSymbol FOREIGN KEY (SymbolID) REFERENCES prodigy.Symbol (SymbolID);

CREATE OR REPLACE VIEW phist.DepthChangeWithOrders AS
	SELECT	SV.SymbolID, DC.SymbolVersionID, DC.SequenceNumber, DC.EventDate, DC.OrderID, DC.ChangeType, DC.Price, DC.Quantity, DC.Position, DC.Market,
			OD.Side, OD.DepthOrderID, EN.Code AS EntityCode, OW.Code AS OwnerContext, OD.ClientContext
	FROM	phist.DepthChange DC
			JOIN phist.SymbolVersion SV ON DC.SymbolVersionID = SV.SymbolVersionID

			JOIN phist.Order OD ON DC.OrderID = OD.OrderID
			JOIN phist.Owner OW ON OD.OwnerID = OW.OwnerID
			JOIN phist.Entity EN ON OW.EntityID = EN.EntityID;

CREATE OR REPLACE VIEW phist.NewsSymbolWithCodes AS
	SELECT	NS.MarketID, NS.SequenceNumber, SV.SymbolID, NS.SymbolVersionID, MA.Code AS MarketCode, SV.Code AS SymbolCode
	FROM	phist.NewsSymbol NS
			JOIN phist.SymbolVersion SV ON NS.SymbolVersionID = SV.SymbolVersionID
			JOIN phist.Symbol SY ON SV.SymbolID = SY.SymbolID
			JOIN phist.Market MA ON SY.MarketID = MA.MarketID
	;

CREATE OR REPLACE VIEW phist.OrderAuditWithContext AS
	SELECT	OA.EntityID, OA.OwnerID, OA.OrderID, OA.Version,
			MA.Code AS MarketCode, SV.Code AS SymbolCode, OD.DepthOrderID, OD.Side,
			OA.EventDate, OA.ExecType, OA.Status, OA.Created, OA.Updated,
			OA.Price, OA.Quantity, OA.MinQuantity, OA.Market, OA.Currency, OA.TimeInForce, OA.ExecInst, OA.ExpiryDate, OA.ExecutedQuantity, OA.ExecutedValue,
			TR.TradeID, TR.Price AS TradePrice, TR.Quantity AS TradeQuantity, TR.Market AS TradeMarket, TR.Aggressor = OD.Side AS Aggressor,
			EN.Code AS EntityCode, OW.Code AS OwnerContext, OD.ClientContext
			--,CO.DepthOrderID AS ContraDepthOrderID
			--,CE.Code AS ContraEntityCode CW.Code AS ContraOwnerContext, CO.ClientContext AS ContraClientContext
	FROM	phist.OrderAudit OA
			JOIN phist.Order OD ON OA.OrderID = OD.OrderID
			JOIN phist.Owner OW ON OD.OwnerID = OW.OwnerID
			JOIN phist.Entity EN ON OW.EntityID = EN.EntityID

			JOIN phist.SymbolVersion SV ON OA.SymbolVersionID = SV.SymbolVersionID
			JOIN phist.Symbol SY ON SV.SymbolID = SY.SymbolID
			JOIN phist.Market MA ON SY.MarketID = MA.MarketID

			LEFT JOIN phist.Trade TR ON OA.SymbolVersionID = TR.SymbolVersionID AND OA.SequenceNumber = TR.SequenceNumber

--			LEFT JOIN phist.Order CO ON OA.ContraOrderID = CO.OrderID
--			LEFT JOIN phist.Owner CW ON CO.OwnerID = CW.OwnerID
--			LEFT JOIN phist.Entity CE ON CW.EntityID = CE.EntityID
	;

CREATE OR REPLACE VIEW phist.TradeWithOrders AS
	SELECT	SV.SymbolID, SV.SymbolVersionID, SV.Code, TR.SequenceNumber, TR.TradeID, TR.EventDate, TR.Price, TR.Quantity, TR.Aggressor, TR.Market, TR.Statistics, TR.Status,
			BO.DepthOrderID AS BuyOrderID, BE.Code AS BuyEntityCode, BW.Code AS BuyOwnerContext, BO.ClientContext AS BuyClientContext,
			SO.DepthOrderID AS SellOrderID, SE.Code AS SellEntityCode, SW.Code AS SellOwnerContext, SO.ClientContext AS SellClientContext
	FROM	phist.Trade TR
			JOIN phist.SymbolVersion SV ON TR.SymbolVersionID = SV.SymbolVersionID

			JOIN phist.Order BO ON TR.BuyOrderID = BO.OrderID
			JOIN phist.Owner BW ON BO.OwnerID = BW.OwnerID
			JOIN phist.Entity BE ON BW.EntityID = BE.EntityID

			JOIN phist.Order SO ON TR.SellOrderID = SO.OrderID
			JOIN phist.Owner SW ON SO.OwnerID = SW.OwnerID
			JOIN phist.Entity SE ON SW.EntityID = SE.EntityID
	;

CREATE OR REPLACE FUNCTION fix.AccountCheckPassword(_name VARCHAR, _hash BYTEA) RETURNS BOOLEAN AS $$
DECLARE
	_testHash BYTEA;
BEGIN
	SELECT	AC.Password INTO _testHash
	FROM	fix.Account AC
	WHERE	AC.Name = _name AND AC.Status != 'DE';

	RETURN _testHash = _hash;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.AccountCheckSession(_name VARCHAR, _beginString VARCHAR, _sender VARCHAR, _target VARCHAR, _qualifiers VARCHAR, _applVerId VARCHAR)
	RETURNS TABLE (
		 SessionID INTEGER
		,IsTransient BOOLEAN
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SE.SessionID, SE.IsTransient
	FROM	fix.Account AC
			JOIN fix.Session SE ON SE.AccountID = AC.AccountID
	WHERE	AC.Name = _name AND AC.Status != 'DE' AND SE.BeginString = _beginString AND SE.Sender = _sender AND SE.Target = _target
			AND (_qualifiers IS NULL AND SE.Qualifiers IS NULL OR _qualifiers = SE.Qualifiers)
			AND (_applVerID IS NULL AND SE.ApplVerID IS NULL OR _applVerID = ApplVerID);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.AccountGet(_name VARCHAR)
	RETURNS TABLE (
	 Name VARCHAR
	,ExternalID VARCHAR
	,Status CHAR(2)
	,Description TEXT
	,Permissions VARCHAR
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	AC.Name, AC.ExternalID, AC.Status, AC.Description, AC.Permissions
	FROM	fix.Account AC
	WHERE	AC.Name = _name AND AC.Status != 'DE';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.AccountGetByExternal(_externalId VARCHAR)
	RETURNS TABLE (
	 Name VARCHAR
	,ExternalID VARCHAR
	,Status CHAR(2)
	,Description VARCHAR
	,Permissions VARCHAR
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	AC.Name, AC.ExternalID, AC.Status, AC.Description, AC.Permissions
	FROM	fix.Account AC
	WHERE	AC.ExternalID = _externalId AND AC.Status != 'DE';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.AccountGetEntityAccessRights(_name VARCHAR)
	RETURNS TABLE (
	 Entity VARCHAR(16)
	,CanTrade BOOLEAN
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	UN.Code, BOOL_OR(UN.CanTrade)
	FROM	(
			-- An Account can access any Entity that its associated Sessions can access
			-- If any Session can trade as an Entity, we say they can trade that Entity
			SELECT	EN.Code, SEE.CanTrade
			FROM	fix.Account AC
					JOIN fix.Session SE ON AC.AccountID = SE.AccountID
					JOIN fix.SessionEntity SEE ON SE.SessionID = SEE.SessionID
					JOIN fix.Entity EN ON EN.EntityID = SEE.EntityID
			WHERE	AC.Name = _name
			UNION
			SELECT	EN.Code, FALSE AS CanTrade
			FROM	fix.Account AC
					JOIN fix.AccountEntity ACE ON AC.AccountID = ACE.AccountID
					JOIN fix.Entity EN ON EN.EntityID = ACE.EntityID
			WHERE	AC.Name = _name
			) UN
	GROUP BY UN.Code;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.AccountGetEntityAccessRightsByExternal(_externalId VARCHAR)
	RETURNS TABLE (
	 Entity VARCHAR(16)
	,CanTrade BOOLEAN
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	UN.Code, BOOL_OR(UN.CanTrade)
	FROM	(
			-- An Account can access any Entity that its associated Sessions can access
			-- If any Session can trade as an Entity, we say they can trade that Entity
			SELECT	EN.Code, SEE.CanTrade
			FROM	fix.Account AC
					JOIN fix.Session SE ON AC.AccountID = SE.AccountID
					JOIN fix.SessionEntity SEE ON SE.SessionID = SEE.SessionID
					JOIN fix.Entity EN ON EN.EntityID = SEE.EntityID
			WHERE	AC.ExternalID = _externalId
			UNION
			SELECT	EN.Code, FALSE AS CanTrade
			FROM	fix.Account AC
					JOIN fix.AccountEntity ACE ON AC.AccountID = ACE.AccountID
					JOIN fix.Entity EN ON EN.EntityID = ACE.EntityID
			WHERE	AC.ExternalID = _externalId
			) UN
	GROUP BY UN.Code;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.AccountGetMarketAccessRights(_name VARCHAR)
	RETURNS TABLE (
	 Market VARCHAR(16)
	,CanTrade BOOLEAN
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SM.MarketCode, BOOL_OR(SM.CanTrade)
	FROM	fix.Account AC
			JOIN fix.Session SE ON AC.AccountID = SE.AccountID
			JOIN fix.SessionMarket SM ON SE.SessionID = SM.SessionID
	WHERE	AC.Name = _name
	GROUP BY SM.MarketCode;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.AccountGetMarketAccessRightsByExternal(_externalId VARCHAR)
	RETURNS TABLE (
	 Market VARCHAR(16)
	,CanTrade BOOLEAN
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SM.MarketCode, BOOL_OR(SM.CanTrade)
	FROM	fix.Account AC
			JOIN fix.Session SE ON AC.AccountID = SE.AccountID
			JOIN fix.SessionMarket SM ON SE.SessionID = SM.SessionID
	WHERE	AC.ExternalID = _externalId
	GROUP BY SM.MarketCode;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.AccountGetPasswordSalt(_name VARCHAR) RETURNS BYTEA AS $$
BEGIN
	RETURN (
	SELECT	AC.Salt
	FROM	fix.Account AC
	WHERE	AC.Name = _name AND AC.Status != 'DE'
	);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.EntityCreate (_code VARCHAR(16), _type CHAR(2), _name TEXT) RETURNS BOOLEAN AS $$
DECLARE
	_entityID INTEGER;
BEGIN
	INSERT INTO fix.Entity (Code, Type, Name)
		VALUES (_code, _type, _name)
		ON CONFLICT DO NOTHING
		RETURNING EntityID INTO _entityID;

	RETURN _entityID IS NOT NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.EntityDelete(_code VARCHAR(16)) RETURNS BOOLEAN AS $$
DECLARE
	_oldEntityID INTEGER;
BEGIN
	UPDATE	fix.Entity EN
	SET		IsDeleted = TRUE
	WHERE	EN.Code = _code AND EN.IsDeleted = FALSE
	RETURNING EntityID INTO _oldEntityID;

	RETURN _oldEntityID IS NOT NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.EntityGet(_code VARCHAR(16))
	RETURNS TABLE (
	 Code VARCHAR(16)
	,Type CHAR(2)
	,Name TEXT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	EN.Code, EN.Type, EN.Name
	FROM	fix.Entity EN
	WHERE	EN.Code = _code AND EN.IsDeleted = FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.EntityGetAccounts(_code VARCHAR, _startIndex INTEGER, _count INTEGER)
	RETURNS TABLE (
	 Name VARCHAR
	,ExternalID VARCHAR
	,Status CHAR(2)
	,Description TEXT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	AC.Name, AC.ExternalID, AC.Status, AC.Description
	FROM	fix.Entity EN
			JOIN fix.Account AC ON EN.EntityID = AC.EntityID
	WHERE	EN.Code = _code AND EN.IsDeleted = FALSE
	ORDER BY AC.Name
	OFFSET (_count) FETCH NEXT (_startIndex) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.EntityGetAll(_startIndex INTEGER, _count INTEGER)
	RETURNS TABLE (
	 Code VARCHAR(16)
	,Type CHAR(2)
	,Name TEXT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	EN.Code, EN.Type, EN.Name
	FROM	fix.Entity EN
	WHERE	EN.IsDeleted = FALSE
	ORDER BY EN.Code
	OFFSET (_startIndex) FETCH NEXT (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.EntityUpdate (_code VARCHAR(16), _type CHAR(2), _name TEXT) RETURNS BOOLEAN AS $$
DECLARE
	_entityID INTEGER;
BEGIN
	UPDATE	fix.Entity EN
	SET		 Type = _type
			,Name = _name
	WHERE	EN.Code = _code AND EN.IsDeleted = FALSE
	RETURNING EntityID INTO _entityID;

	RETURN _entityID IS NOT NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionAddEntityAccessRight(_sessionId INTEGER, _entity VARCHAR(16), _canTrade BOOLEAN) RETURNS VOID AS $$
DECLARE
	_entityId INTEGER;
BEGIN
	SELECT	EntityID INTO _entityId
	FROM	fix.Entity EN
	WHERE	EN.Code = _entity;
	
	IF EntityID IS NULL THEN
		RAISE EXCEPTION 'Entity (%) does not exist', _code USING ERRCODE = 'foreign_key_violation';

		RETURN;
	END IF;		

	INSERT INTO fix.SessionEntity (SessionID, EntityID, CanTrade)
		VALUES (_sessionId, _entityId, _canTrade);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionAddMarketAccessRight(_sessionId INTEGER, _market VARCHAR(16), _canTrade BOOLEAN) RETURNS VOID AS $$
BEGIN
	INSERT INTO fix.SessionMarket (SessionID, MarketCode, CanTrade)
		VALUES (_sessionId, _market, _canTrade);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionBeginReset(_sessionId INTEGER) RETURNS VOID AS $$
BEGIN
	UPDATE	fix.Session
	SET		ResetOnNextLogin = TRUE
	WHERE	SessionID = _sessionId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionGet(_beginString VARCHAR, _sender VARCHAR, _target VARCHAR, _qualifiers VARCHAR, _applVerId VARCHAR)
	RETURNS TABLE (
	 SessionID INTEGER
	,IsTransient BOOLEAN
	,SentSequenceNumber BIGINT
	,ReceivedSequenceNumber BIGINT
	,ResetOnNextLogin BOOLEAN
	,StartedDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SE.SessionID, SE.IsTransient,
			(SELECT MAX(SequenceNumber) FROM fix.Message FM WHERE FM.SessionID = SE.SessionID AND FM.IsOutgoing = TRUE) AS SentSequenceNumber,
			(SELECT MAX(SequenceNumber) FROM fix.Message FM WHERE FM.SessionID = SE.SessionID AND FM.IsOutgoing = FALSE) AS ReceivedSequenceNumber,
			SE.ResetOnNextLogin, SE.StartedDate,
			SE.Data
	FROM	fix.Session SE
	WHERE	SE.BeginString = _beginString AND SE.Sender = _sender AND SE.Target = _target
			AND (_qualifiers IS NULL AND SE.Qualifiers IS NULL OR _qualifiers = SE.Qualifiers)
			AND (_applVerID IS NULL AND SE.ApplVerID IS NULL OR _applVerID = SE.ApplVerID);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionGetAccounts(_sessionId INTEGER)
	RETURNS TABLE (
	 Name VARCHAR
	,ExternalID VARCHAR
	,Status CHAR(2)
	,Description TEXT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	AC.Name, AC.ExternalID, AC.Status, AC.Description
	FROM	fix.Account AC
			JOIN fix.AccountSession SA ON AC.AccountID = SA.AccountID
	WHERE	SA.SessionID = _sessionId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionGetAll(_startIndex INTEGER, _count INTEGER)
	RETURNS TABLE (
	 BeginString VARCHAR
	,Sender VARCHAR
	,Target VARCHAR
	,Qualifiers VARCHAR
	,ApplVerID VARCHAR
	,IsTransient BOOLEAN
	,ResetOnNextLogin BOOLEAN
	,StartedDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SE.BeginString, SE.Sender, SE.Target, SE.Qualifiers, SE.ApplVerID,
			SE.IsTransient, SE.ResetOnNextLogin, SE.StarteDate, SE.Data
	FROM	fix.Session SE
	ORDER BY SE.BeginString, SE.ApplVerID, SE.Sender, SE.Target, SE.Qualifiers ASC
	OFFSET (_startIndex) FETCH NEXT (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionGetById(_sessionId INTEGER)
	RETURNS TABLE (
	 SessionID INTEGER
	,BeginString VARCHAR
	,Sender VARCHAR
	,Target VARCHAR
	,Qualifiers VARCHAR
	,ApplVerID VARCHAR
	,IsTransient BOOLEAN
	,SentSequenceNumber BIGINT
	,ReceivedSequenceNumber BIGINT
	,ResetOnNextLogin BOOLEAN
	,StartedDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SE.SessionID, SE.BeginString, SE.Sender, SE.Target, SE.Qualifiers, SE.ApplVerID, SE.IsTransient,
			(SELECT MAX(SequenceNumber) FROM fix.Message FM WHERE FM.SessionID = SE.SessionID AND FM.IsOutgoing = TRUE) AS SentSequenceNumber,
			(SELECT MAX(SequenceNumber) FROM fix.Message FM WHERE FM.SessionID = SE.SessionID AND FM.IsOutgoing = FALSE) AS ReceivedSequenceNumber,
			SE.ResetOnNextLogin, SE.StartedDate,
			SE.Data
	FROM	fix.Session SE
	WHERE	SE.SessionID = _sessionId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionGetEntityAccessRights(_sessionId INTEGER)
	RETURNS TABLE (
	 Entity VARCHAR(16)
	,CanTrade BOOLEAN
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	UN.Code, BOOL_OR(UN.CanTrade)
	FROM	(
			SELECT	EN.Code, SEE.CanTrade
			FROM	fix.SessionEntity SEE
					JOIN fix.Entity EN ON EN.EntityID = SEE.EntityID
			WHERE	SEE.SessionID = _sessionId
			UNION
			SELECT	EN.Code, FALSE AS CanTrade
			FROM	fix.Session SE
					JOIN fix.AccountEntity ACE ON SE.AccountID = ACE.AccountID
					JOIN fix.Entity EN ON EN.EntityID = ACE.EntityID
			WHERE	SE.SessionID = _sessionId
			) UN
	GROUP BY UN.Code;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionGetMarketAccessRights(_sessionId INTEGER)
	RETURNS TABLE (
	 Market VARCHAR(16)
	,CanTrade BOOLEAN
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SM.MarketCode, SM.CanTrade
	FROM	fix.SessionMarket SM
	WHERE	SM.SessionID = _sessionId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionGetMessages(_sessionId INTEGER, _isOutgoing BOOLEAN, _beginSequenceNumber BIGINT, _endSequenceNumber BIGINT)
	RETURNS TABLE (
	 SequenceNumber BIGINT
	,SentAt TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	,Context BYTEA
	) AS $$
BEGIN
	IF _endSequenceNumber IS NULL THEN
		RETURN QUERY
		SELECT	FM.SequenceNumber, FM.SentAt, FM.Data, FM.Context
		FROM	fix.Message FM
		WHERE	FM.SessionID = _sessionId AND FM.IsOutgoing = _isOutgoing AND FM.SequenceNumber >= _beginSequenceNumber
		ORDER BY FM.SequenceNumber ASC;

		RETURN;
	END IF;

	RETURN QUERY
	SELECT	FM.SequenceNumber, FM.SentAt, FM.Data, FM.Context
	FROM	fix.Message FM
	WHERE	FM.SessionID = _sessionId AND FM.IsOutgoing = _isOutgoing AND FM.SequenceNumber >= _beginSequenceNumber AND FM.SequenceNumber <= _endSequenceNumber
	ORDER BY FM.SequenceNumber ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionGetSnapshot(_sessionId INTEGER, _marketCode VARCHAR)
	RETURNS TABLE (
	 SequenceNumber BIGINT
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SS.SequenceNumber, SS.Data
	FROM	fix.SessionSnapshot SS
	WHERE	SS.SessionID = _sessionId AND SS.MarketCode = _marketCode;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionRecordLogin(_sessionId INTEGER, _username VARCHAR, _sourceIp INET, _sourcePort INTEGER, _targetIp INET, _targetPort INTEGER) RETURNS INTEGER AS $$
DECLARE
	_accountID INTEGER;
	_loginID INTEGER;
BEGIN
	SELECT	AC.AccountID INTO _accountID
	FROM	fix.Account AC
	WHERE	AC.Name = _username;

	IF _accountID IS NULL THEN
		RAISE EXCEPTION 'User (%) does not exist', _username;

		RETURN -1;
	END IF;

	INSERT INTO fix.Login (SessionID, AccountID, LogonAt, SourceIP, SourcePort, TargetIP, TargetPort)
		VALUES (_sessionId, _accountID, CURRENT_TIMESTAMP, _sourceIp, _sourcePort, _targetIp, _targetPort)
		RETURNING LoginID INTO _loginID;

	RETURN _loginID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionRecordLogoff(_loginId INTEGER, _reason TEXT) RETURNS VOID AS $$
BEGIN
	UPDATE	fix.Login
	SET		 LogoffAt = CURRENT_TIMESTAMP
			,LogoffReason = _reason
	WHERE	LoginID = _loginId AND LogoffAt IS NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionRecordMessage(_sessionId INTEGER, _isOutgoing BOOLEAN, _sequenceNumber BIGINT, _data BYTEA, _context BYTEA) RETURNS VOID AS $$
BEGIN
	INSERT INTO fix.Message (SessionID, IsOutgoing, SequenceNumber, SentAt, Data, Context)
		VALUES (_sessionId, _isOutgoing, _sequenceNumber, CURRENT_TIMESTAMP, _data, _context)
		ON CONFLICT DO NOTHING;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionRemoveEntityAccessRight(_sessionId INTEGER, _entity VARCHAR(16)) RETURNS VOID AS $$
DECLARE
	_entityId INTEGER;
BEGIN
	SELECT	EntityID INTO _entityId
	FROM	fix.Entity EN
	WHERE	EN.Code = _entity;
	
	IF EntityID IS NULL THEN
		RETURN;
	END IF;
	
	DELETE
	FROM	fix.SessionEntity
	WHERE	SessionID = _sessionId AND EntityID = _entityId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionRemoveMarketAccessRight(_sessionId INTEGER, _market VARCHAR(16)) RETURNS VOID AS $$
BEGIN
	DELETE
	FROM	fix.SessionMarket
	WHERE	SessionID = _sessionId AND MarketCode = _market;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionReset(_sessionId INTEGER) RETURNS VOID AS $$
BEGIN
	DELETE
	FROM	fix.Message
	WHERE	SessionID = _sessionId;

	UPDATE	fix.Session
	SET		ResetOnNextLogin = FALSE, StartedDate = NULL
	WHERE	SessionID = _sessionId;

	DELETE
	FROM    fix.SessionSnapshot
	WHERE   SessionID = _sessionId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionSaveState(_sessionId INTEGER, _resetOnNextLogin BOOLEAN, _startedDate TIMESTAMP WITH TIME ZONE) RETURNS VOID AS $$
BEGIN
	UPDATE	fix.Session
	SET		ResetOnNextLogin = _resetOnNextLogin, StartedDate = _startedDate
	WHERE	SessionID = _sessionId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionUpdateEntityAccessRight(_sessionId INTEGER, _entity VARCHAR(16), _canTrade BOOLEAN) RETURNS VOID AS $$
DECLARE
	_entityId INTEGER;
BEGIN
	SELECT	EntityID INTO _entityId
	FROM	fix.Entity EN
	WHERE	EN.Code = _entity;
	
	IF EntityID IS NULL THEN
		RAISE EXCEPTION 'Entity (%) does not exist', _code USING ERRCODE = 'foreign_key_violation';

		RETURN;
	END IF;
	
	UPDATE	fix.SessionEntity
	SET		CanTrade = _canTrade
	WHERE	SessionID = _sessionId AND EntityID = _entityID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionUpdateMarketAccessRight(_sessionId INTEGER, _market VARCHAR(16), _canTrade BOOLEAN) RETURNS VOID AS $$
BEGIN
	UPDATE	fix.SessionMarket
	SET		CanTrade = _canTrade
	WHERE	SessionID = _sessionId AND MarketCode = _market;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SessionUpdateSnapshot(_sessionId INTEGER, _marketCode VARCHAR, _sequenceNumber BIGINT, _data BYTEA) RETURNS VOID AS $$
BEGIN
	INSERT INTO fix.SessionSnapshot (SessionID, MarketCode, SequenceNumber, Data)
		VALUES (_sessionId, _marketCode, _sequenceNumber, _data)
	ON CONFLICT (SessionID, MarketCode) DO UPDATE
	SET  SequenceNumber = _sequenceNumber
		,Data = _data;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SubscriptionCreate(_sessionId INTEGER, _requestId VARCHAR, _subscriptionType CHAR(2), _data BYTEA) RETURNS VOID AS $$
BEGIN
	INSERT INTO fix.Subscription (SessionID, RequestID, SubscriptionType, Data)
		VALUES (_sessionId, _requestId, _subscriptionType, _data);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SubscriptionGet(_sessionId INTEGER)
	RETURNS TABLE (
	 RequestID VARCHAR
	,SubscriptionType CHAR(2)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	FS.RequestID, FS.SubscriptionType, FS.Data
	FROM	fix.Subscription FS
	WHERE	FS.SessionID = _sessionId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SubscriptionGetAll(_sessionId INTEGER, _startIndex INTEGER, _count INTEGER)
	RETURNS TABLE (
	 RequestID VARCHAR
	,SubscriptionType CHAR(2)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	FS.RequestID, FS.SubscriptionType, FS.Data
	FROM	fix.Subscription FS
	WHERE	FS.SessionID = _sessionId
	ORDER BY FS.RequestID ASC
	OFFSET (_startIndex) FETCH NEXT (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION fix.SubscriptionRelease(_sessionId INTEGER, _requestId VARCHAR, _subscriptionType CHAR(2)) RETURNS VOID AS $$
BEGIN
	DELETE
	FROM	fix.Subscription
	WHERE	SessionID = _sessionId AND RequestID = _requestId AND SubscriptionType = _subscriptionType;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.DepthChangeAdd(
	 _symbolVersionId BIGINT
	,_sequenceNumber BIGINT

	,_orderId BIGINT

	,_eventDate TIMESTAMP WITH TIME ZONE
	,_changeType CHAR(1)

	,_price DECIMAL
	,_quantity BIGINT
	,_position BIGINT
	,_market VARCHAR(16)
	) RETURNS VOID AS $$
BEGIN
	INSERT INTO phist.DepthChange (SymbolVersionID, SequenceNumber, EventDate, ChangeType, OrderID, Price, Quantity, Position, Market)
		VALUES (_symbolVersionId, _sequenceNumber, _eventDate, _changeType, _orderId, _price, _quantity, _position, _market)
		ON CONFLICT DO NOTHING; -- Allow multiple archivers to work concurrently
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.DepthChangeGetAll(_symbolId BIGINT, _fromSequenceNumber BIGINT, _toSequenceNumber BIGINT, _fromDate TIMESTAMP WITH TIME ZONE, _toDate TIMESTAMP WITH TIME ZONE, _count INTEGER, _isAscending BOOLEAN)
	RETURNS TABLE (
	 SequenceNumber BIGINT

	,EventDate TIMESTAMP WITH TIME ZONE
	,ChangeType CHAR(1)
	,OrderID BIGINT

	,Side CHAR(1)
	,Price DECIMAL
	,Quantity BIGINT
	,"Position" BIGINT
	,Market VARCHAR(16)

	,EntityCode VARCHAR(16)
	,OwnerContext TEXT
	,ClientContext TEXT
	) AS $$
BEGIN
	IF _isAscending THEN
		RETURN QUERY
		SELECT	DW.EventID, DW.EventDate, DW.ChangeType, DW.DepthOrderID,
				DW.Side, DW.Price, DW.Quantity, DW.Position, DW.Market,
				DW.EntityCode, DW.OwnerContext, DW.ClientContext
		FROM	phist.DepthChangeWithOrders DW
		WHERE	DW.SymbolID = _symbolId
				AND (_fromSequenceNumber IS NULL OR DW.SequenceNumber >= _fromSequenceNumber) AND (_toSequenceNumber IS NULL OR DW.SequenceNumber <= _toSequenceNumber)
				AND (_fromDate IS NULL OR DW.EventDate >= _fromDate) AND (_toDate IS NULL OR DW.EventDate <= _toDate)
		ORDER BY DW.SequenceNumber ASC
		FETCH NEXT (_count) ROWS ONLY;
	ELSE
		RETURN QUERY
		SELECT	DW.EventID, DW.EventDate, DW.ChangeType, DW.DepthOrderID,
				DW.Side, DW.Price, DW.Quantity, DW.Position, DW.Market,
				DW.EntityCode, DW.OwnerContext, DW.ClientContext
		FROM	phist.DepthChangeWithOrders DW
		WHERE	DW.SymbolID = _symbolId
				AND (_fromSequenceNumber IS NULL OR DW.SequenceNumber >= _fromSequenceNumber) AND (_toSequenceNumber IS NULL OR DW.SequenceNumber <= _toSequenceNumber)
				AND (_fromDate IS NULL OR DW.EventDate >= _fromDate) AND (_toDate IS NULL OR DW.EventDate <= _toDate)
		ORDER BY DW.SequenceNumber DESC
		FETCH NEXT (_count) ROWS ONLY;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.EntityCreate (_code VARCHAR(16)) RETURNS INTEGER AS $$
DECLARE
	_entityID INTEGER;
BEGIN
	INSERT INTO phist.Entity (Code)
		VALUES (_code)
		RETURNING EntityID INTO _entityID;

	RETURN _entityID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.EntityDelete(_entityId INTEGER) RETURNS VOID AS $$
BEGIN
	UPDATE	phist.Entity EN
	SET		IsDeleted = TRUE
	WHERE	EN.EntityID = _entityId AND EN.IsDeleted = FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.EntityEnsureExists(_code VARCHAR) RETURNS INTEGER AS $$
DECLARE
	_EntityID INTEGER;
BEGIN
	LOOP
		SELECT	EN.EntityID INTO _EntityID
		FROM	phist.Entity EN
		WHERE	EN.Code = _code AND EN.IsDeleted = FALSE;
		
		EXIT WHEN FOUND;

		INSERT INTO phist.Entity (Code)
		VALUES      (_code)
		ON CONFLICT DO NOTHING
		RETURNING EntityID INTO _EntityID;
		
		EXIT WHEN FOUND;
	END LOOP;

	RETURN _EntityID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.EntityGet(_code VARCHAR) RETURNS INTEGER AS $$
DECLARE
	_entityId INTEGER;
BEGIN
	SELECT	EN.EntityID INTO _entityID
	FROM	phist.Entity EN
	WHERE	EN.Code = _code AND EN.IsDeleted = FALSE;

	RETURN _entityID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.MarketCreate(_code VARCHAR) RETURNS INTEGER AS $$
DECLARE
	_marketID INTEGER;
BEGIN
	SELECT	MarketID INTO _marketID
	FROM	phist.Market
	WHERE	Code = _code;

	IF _marketID IS NULL THEN
		INSERT INTO phist.Market (Code)
			VALUES (_code)
			RETURNING MarketID INTO _marketID;
	END IF;

	RETURN _marketID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.MarketDelete(_code VARCHAR) RETURNS BOOLEAN AS $$
DECLARE
	_marketID INTEGER;
BEGIN
	SELECT	MA.MarketID INTO _marketID
	FROM	phist.Market MA
	WHERE	MA.Code = _code AND MA.IsDeleted = FALSE;

	IF _marketID IS NULL THEN
		RETURN FALSE;
	END IF;

	-- Marks the Market as deleted.
	-- It will no longer be returned from procedures like MarketGetAll, etc
	UPDATE	phist.Market
	SET		IsDeleted = TRUE
	WHERE	MarketID = _marketID;

	RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.MarketGet(_code VARCHAR) RETURNS INTEGER AS $$
DECLARE
	_marketID INTEGER;
BEGIN
	SELECT	MA.MarketID INTO _marketID
	FROM	phist.Market MA
	WHERE	MA.Code = _code AND MA.IsDeleted = FALSE;

	RETURN _marketID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.MarketGetCharts(_marketId INTEGER, _from TIMESTAMP WITH TIME ZONE, _to TIMESTAMP WITH TIME ZONE, _count INTEGER, _interval INTEGER, _isAscending BOOLEAN)
	RETURNS TABLE (
	 Code VARCHAR(16)
	,RecordDate TIMESTAMP WITH TIME ZONE

	,OpeningPrice DECIMAL
	,HighPrice DECIMAL
	,LowPrice DECIMAL
	,ClosingPrice DECIMAL
	
	,NumberOfTrades INTEGER
	,Volume BIGINT
	) AS $$
DECLARE
	_PartitionBy TEXT;
	_OrderByDirection TEXT;
BEGIN
	_OrderByDirection := CASE WHEN _isAscending = TRUE THEN 'ASC' ELSE 'DESC' END;

	IF _interval < 60 THEN
		IF 60 % _interval != 0 THEN
			RAISE EXCEPTION 'Interval (%) does not divide evenly into 60 minutes', _interval;
		END IF;

		_PartitionBy := 'RoundToMinute(TR.EventDate, $1)';
	ELSIF _interval < 60 * 24 THEN
		IF _interval % 60 != 0 THEN
			RAISE EXCEPTION 'Interval (%) is not a multiple of one hour', _interval;
		END IF;

		_interval := _interval / 60;

		IF 24 % _interval != 0 THEN
			RAISE EXCEPTION 'Interval (%) does not divide evenly into 24 hours', _interval;
		END IF;

		_PartitionBy := 'RoundToHour(TR.EventDate, $1)';
	ELSE
		IF _interval % (60 * 24) != 0 THEN
			RAISE EXCEPTION 'Interval (%) is not a multiple of one day', _interval;
		END IF;

		_interval := _interval / (60 * 24);

		IF _interval = 1 THEN
			_PartitionBy := 'DATE_TRUNC(''DAY'', TR.EventDate)';
		ELSIF _interval = 7 THEN
			_PartitionBy := 'DATE_TRUNC(''WEEK'', TR.EventDate)';
		ELSIF _interval = 30 THEN
			_PartitionBy := 'DATE_TRUNC(''MONTH'', TR.EventDate)';
		ELSIF _interval = 90 THEN
			_PartitionBy := 'DATE_TRUNC(''QUARTER'', TR.EventDate)';
		ELSIF _interval = 365 THEN
			_PartitionBy := 'DATE_TRUNC(''YEAR'', TR.EventDate)';
		ELSIF _interval % 7 = 0 THEN
			-- Support for fortnights and larger week intervals
			_interval := _interval / 7;

			_PartitionBy := 'RoundToWeek(TR.EventDate, $1)';
		ELSE
			RAISE EXCEPTION 'Interval (%) is not a valid day value', _interval;
		END IF;
	END IF;

	RETURN QUERY EXECUTE FORMAT($A$
		SELECT	GD.Code, GD.RecordDate, GD.OpeningPrice, GD.HighPrice, GD.LowPrice, GD.ClosingPrice, GD.NumberOfTrades, GD.Volume
		FROM	(
				SELECT	 SY.Code
						,%1$s AS RecordDate
						,FIRST_VALUE(TR.Price) OVER Candle AS OpeningPrice
						,MAX(TR.Price)         OVER Candle AS HighPrice
						,MIN(TR.Price)         OVER Candle AS LowPrice
						,LAST_VALUE(TR.Price)  OVER Candle AS ClosingPrice
						,(COUNT(*)             OVER Candle)::INT AS NumberOfTrades
						,(SUM(TR.Quantity)     OVER Candle)::BIGINT AS Volume
						,ROW_NUMBER()          OVER (PARTITION BY %1$s ORDER BY TR.EventDate %2$s) AS RowNumber
				FROM	phist.Trade TR
						JOIN phist.Symbol SY ON TR.SymbolID = SY.SymbolID
				WHERE	SY.MarketID = $2 AND ($3 IS NULL OR $3 <= TR.EventDate) AND ($4 IS NULL OR $4 >= TR.EventDate)
				WINDOW	Candle AS (PARTITION BY %1$s ORDER BY TR.EventDate)
				) GD
		WHERE	GD.RowNumber = 1
		FETCH FIRST ($5) ROWS ONLY;
		$A$,
		_PartitionBy,
		_OrderByDirection
		) USING _interval, _marketId, _from, _to, _count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.MarketGetLatest(_code VARCHAR) RETURNS TIMESTAMP WITH TIME ZONE AS $$
BEGIN
	RETURN (
			SELECT	MAX(ED.EventDate)
			FROM	(
					SELECT	MAX(TR.EventDate) AS EventDate
					FROM	phist.Trade TR
							JOIN phist.SymbolVersion SV ON TR.SymbolVersionID = SV.SymbolVersionID
							JOIN phist.Symbol SY ON SV.SymbolID = SY.SymbolID
							JOIN phist.Market MA ON SY.MarketID = MA.MarketID
					WHERE	MA.Code = _code
					UNION ALL
					SELECT	MAX(DC.EventDate)
					FROM	phist.DepthChange DC
							JOIN phist.SymbolVersion SV ON DC.SymbolVersionID = SV.SymbolVersionID
							JOIN phist.Symbol SY ON SV.SymbolID = SY.SymbolID
							JOIN phist.Market MA ON SY.MarketID = MA.MarketID
					WHERE	MA.Code = _code
					UNION ALL
					SELECT	MAX(NE.EventDate)
					FROM	phist.News NE
							JOIN phist.Market MA ON NE.MarketID = MA.MarketID
					WHERE	MA.Code = _code
			) ED
	);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.NewsAdd(_marketId INTEGER, _sequenceNumber BIGINT, _newsId BIGINT, _eventDate TIMESTAMP WITH TIME ZONE, _title TEXT, _priority SMALLINT, _reference VARCHAR(64), _symbolVersions BIGINT[]) RETURNS VOID AS $$
DECLARE
	_newsBodyID BIGINT;
BEGIN
	IF _reference IS NOT NULL THEN
		SELECT	NB.NewsBodyID INTO _newsBodyID
		FROM	phist.NewsBody NB
		WHERE	NB.Reference = _reference;
	END IF;

	INSERT INTO phist.News (MarketID, SequenceNumber, EventDate, NewsID, Title, Priority, NewsBodyID)
		VALUES (_marketId, _sequenceNumber, _eventDate, _newsId, _title, _priority, _newsBodyID);

	INSERT INTO phist.NewsSymbol (MarketID, SequenceNumber, SymbolVersionID)
		SELECT	_marketId, _sequenceNumber, SY.SymbolVersionID
		FROM	UNNEST(_symbolVersions) AS SY (SymbolVersionID);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.NewsGetByMarket (_marketId INTEGER, _fromSequenceNumber BIGINT, _toSequenceNumber BIGINT, _fromDate TIMESTAMP WITH TIME ZONE, _toDate TIMESTAMP WITH TIME ZONE, _count INTEGER, _isAscending BOOLEAN)
	RETURNS TABLE (
	 SequenceNumber BIGINT

	,EventDate TIMESTAMP WITH TIME ZONE
	,NewsID BIGINT
	,Title TEXT

	,Priority SMALLINT
	,Reference VARCHAR(64)

	,MarketCode VARCHAR(16)[]
	,SymbolCode VARCHAR(16)[]
	) AS $$
BEGIN
	
	IF _isAscending = TRUE THEN
		RETURN QUERY
		SELECT	NE.SequenceNumber, NE.EventDate, NE.NewsID, NE.Title, NE.Priority, NE.Reference, array_agg(NW.MarketCode), array_agg(NW.SymbolCode)
		FROM	phist.News NE
				LEFT JOIN phist.NewsBody NB ON NE.NewsBodyID = NB.NewsBodyID
				LEFT JOIN phist.NewSymbolWithCodes NW ON NW.MarketID = _marketId AND NW.SequenceNumber = NE.SequenceNumber
		WHERE	NE.MarketID = _marketId
				AND (_fromSequenceNumber IS NULL OR NE.SequenceNumber >= _fromSequenceNumber) AND (_toSequenceNumber IS NULL OR NE.SequenceNumber <= _toSequenceNumber)
				AND (_fromDate IS NULL OR NE.EventDate >= _fromDate) AND (_toDate IS NULL OR NE.EventDate <= _toDate)
		GROUP BY NE.MarketID, NE.SequenceNumber
		ORDER BY NE.SequenceNumber ASC
		FETCH NEXT (_count) ROWS ONLY;
	ELSE
		RETURN QUERY
		SELECT	NE.SequenceNumber, NE.EventDate, NE.NewsID, NE.Title, NE.Priority, NE.Reference, array_agg(NW.MarketCode), array_agg(NW.SymbolCode)
		FROM	phist.News NE
				LEFT JOIN phist.NewsBody NB ON NE.NewsBodyID = NB.NewsBodyID
				LEFT JOIN phist.NewSymbolWithCodes NW ON NW.MarketID = _marketId AND NW.SequenceNumber = NE.SequenceNumber
		WHERE	NE.MarketID = _marketId
				AND (_fromSequenceNumber IS NULL OR NE.SequenceNumber >= _fromSequenceNumber) AND (_toSequenceNumber IS NULL OR NE.SequenceNumber <= _toSequenceNumber)
				AND (_fromDate IS NULL OR NE.EventDate >= _fromDate) AND (_toDate IS NULL OR NE.EventDate <= _toDate)
		GROUP BY NE.MarketID, NE.SequenceNumber
		ORDER BY NE.SequenceNumber DESC
		FETCH NEXT (_count) ROWS ONLY;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.NewsGetBySymbol (_symbolId BIGINT, _fromSequenceNumber BIGINT, _toSequenceNumber BIGINT, _fromDate TIMESTAMP WITH TIME ZONE, _toDate TIMESTAMP WITH TIME ZONE, _count INTEGER, _isAscending BOOLEAN)
	RETURNS TABLE (
	 SequenceNumber BIGINT

	,EventDate TIMESTAMP WITH TIME ZONE
	,NewsID BIGINT
	,Title TEXT

	,Priority SMALLINT
	,Reference VARCHAR(64)

	,MarketCode VARCHAR(16)[]
	,SymbolCode VARCHAR(16)[]
	) AS $$
BEGIN
	
	IF _isAscending = TRUE THEN
		RETURN QUERY
		SELECT	NE.SequenceNumber, NE.EventDate, NE.NewsID, NE.Title, NE.Priority, NB.Reference, array_agg(NW.MarketCode), array_agg(NW.SymbolCode)
		FROM	phist.News NE
				JOIN phist.NewsSymbol NS ON NE.MarketID = NS.MarketID AND NE.SequenceNumber = NS.SequenceNumber
				LEFT JOIN phist.NewsBody NB ON NE.NewsBodyID = NB.NewsBodyID
				LEFT JOIN phist.NewSymbolWithCodes NW ON NW.MarketID = _marketId AND NW.SequenceNumber = NE.SequenceNumber
		WHERE	NS.SymbolID = _symbolId
				AND (_fromSequenceNumber IS NULL OR NE.SequenceNumber >= _fromSequenceNumber) AND (_toSequenceNumber IS NULL OR NE.SequenceNumber <= _toSequenceNumber)
				AND (_fromDate IS NULL OR NE.EventDate >= _fromDate) AND (_toDate IS NULL OR NE.EventDate <= _toDate)
		GROUP BY NE.MarketID, NE.SequenceNumber
		ORDER BY NE.SequenceNumber ASC
		FETCH NEXT (_count) ROWS ONLY;
	ELSE
		RETURN QUERY
		SELECT	NE.SequenceNumber, NE.EventDate, NE.NewsID, NE.Title, NE.Priority, NB.Reference, array_agg(NW.MarketCode), array_agg(NW.SymbolCode)
		FROM	phist.News NE
				JOIN phist.NewsSymbol NS ON NE.MarketID = NS.MarketID AND NE.SequenceNumber = NS.SequenceNumber
				LEFT JOIN phist.NewsBody NB ON NE.NewsBodyID = NB.NewsBodyID
				LEFT JOIN phist.NewSymbolWithCodes NW ON NW.MarketID = _marketId AND NW.SequenceNumber = NE.SequenceNumber
		WHERE	NS.SymbolID = _symbolId
				AND (_fromSequenceNumber IS NULL OR NE.SequenceNumber >= _fromSequenceNumber) AND (_toSequenceNumber IS NULL OR NE.SequenceNumber <= _toSequenceNumber)
				AND (_fromDate IS NULL OR NE.EventDate >= _fromDate) AND (_toDate IS NULL OR NE.EventDate <= _toDate)
		GROUP BY NE.MarketID, NE.SequenceNumber
		ORDER BY NE.SequenceNumber DESC
		FETCH NEXT (_count) ROWS ONLY;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.NewsBodyAdd(_fileName TEXT, _reference VARCHAR(64), _mimeType TEXT, _hash BYTEA, _length BIGINT, _comments TEXT) RETURNS TIMESTAMP WITH TIME ZONE AS $$
DECLARE
	_created TIMESTAMP WITH TIME ZONE;
BEGIN
	INSERT INTO phist.NewsBody (Created, FileName, Reference, MimeType, Hash, Length, Comments)
		VALUES (CURRENT_TIMESTAMP, _fileName, _reference, _mimeType, _hash, _length, _comments)
		RETURNING Created INTO _created;

	RETURN _created;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.NewsBodyGetByID(_marketId INTEGER, _sequenceNumber BIGINT)
	RETURNS TABLE (
	 NewsBodyID BIGINT
	,Created TIMESTAMP WITH TIME ZONE

	,FileName TEXT
	,Reference VARCHAR(64)
	,MimeType TEXT
	,Hash BYTEA
	,Length BIGINT

	,Comments TEXT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	NB.NewsBodyID, NB.Created, NB.FileName, NB.Reference, NB.MimeType, NB.Hash, NB.Length, NB.Comments
	FROM	phist.News NE
			JOIN phist.NewsBody NB ON NE.NewsBodyID = NB.NewsBodyID
	WHERE	NE.MarketID = _marketId AND NE.SequenceNumber = _sequenceNumber;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.NewsBodyGetByReference(_reference VARCHAR(64))
	RETURNS TABLE (
	 NewsBodyID BIGINT
	,Created TIMESTAMP WITH TIME ZONE

	,FileName TEXT
	,Reference VARCHAR(64)
	,MimeType TEXT
	,Hash BYTEA
	,Length BIGINT

	,Comments TEXT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	NB.NewsBodyID, NB.Created, NB.FileName, NB.Reference, NB.MimeType, NB.Hash, NB.Length, NB.Comments
	FROM	phist.NewsBody NB
	WHERE	NB.Reference = _reference;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.OrderEnsureExists(_symbolId BIGINT, _depthOrderId BIGINT, _ownerId BIGINT, _side CHAR(1), _clientContext TEXT) RETURNS BIGINT AS $$
DECLARE
	_OrderID BIGINT;
BEGIN
	LOOP
		SELECT  OD.OrderID INTO _OrderID
		FROM    phist.Order OD
		WHERE   OD.SymbolID = _symbolId AND OD.DepthOrderID = _depthOrderId;

		EXIT WHEN FOUND;

		INSERT INTO phist.Order (SymbolID, DepthOrderID, OwnerID, Side, ClientContext)
		VALUES      (_symbolId, _depthOrderId, _ownerId, _side, _clientContext)
		ON CONFLICT (SymbolID, DepthOrderID) DO NOTHING
		RETURNING   OrderID INTO _OrderID;

		EXIT WHEN FOUND;
	END LOOP;

	RETURN _OrderID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.OrderGet(_symbolId BIGINT, _depthOrderId BIGINT) RETURNS BIGINT AS $$
DECLARE
	_orderID BIGINT;
BEGIN
	SELECT	OD.OrderID INTO _orderID
	FROM	phist.Order OD
	WHERE	OD.SymbolID = _symbolId AND OD.DepthOrderID = _depthOrderId;

	RETURN _orderID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.OrderAuditAddStatus(
	 _orderId BIGINT
	,_sequenceNumber BIGINT
	,_version BIGINT
	,_symbolVersionId BIGINT

	,_eventDate TIMESTAMP WITH TIME ZONE
	,_status  CHAR(1)

	,_created TIMESTAMP WITH TIME ZONE
	,_updated TIMESTAMP WITH TIME ZONE

	,_price DECIMAL
	,_quantity BIGINT
	,_minQuantity BIGINT
	,_market VARCHAR(16)

	,_currency VARCHAR(8)
	,_timeInForce CHAR(2)
	,_execInst TEXT
	,_expiryDate TIMESTAMP WITH TIME ZONE

	,_executedQuantity BIGINT
	,_executedValue DECIMAL
	) RETURNS VOID AS $$
BEGIN
	INSERT INTO phist.OrderAudit (OrderID, SequenceNumber, Version, EntityID, OwnerID, SymbolVersionID, EventDate, ExecType, Status, Created, Updated, Price, Quantity, MinQuantity, Market, Currency, TimeInForce, ExecInst, ExpiryDate, ExecutedQuantity, ExecutedValue)
		SELECT	_orderId, _sequenceNumber, _version, OW.EntityID, OD.OwnerID, _symbolVersionId,  _eventDate, 'S', _status, _created, _updated, _price, _quantity, _minquantity, _market, _currency, _timeInForce, _execInst, _expiryDate, _executedQuantity, _executedValue
		FROM	phist.Order OD
				JOIN phist.Owner OW ON OW.OwnerID = OD.OwnerID
		WHERE	OD.OrderID = _orderId
		ON CONFLICT DO NOTHING; -- Allow multiple archivers to work concurrently
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.OrderAuditAddTrade(
	 _orderId BIGINT
	,_sequenceNumber BIGINT
	,_version BIGINT
	,_symbolVersionId BIGINT

	,_eventDate TIMESTAMP WITH TIME ZONE
	,_status  CHAR(1)

	,_created TIMESTAMP WITH TIME ZONE
	,_updated TIMESTAMP WITH TIME ZONE

	,_price DECIMAL
	,_quantity BIGINT
	,_minQuantity BIGINT
	,_market VARCHAR(16)

	,_currency VARCHAR(8)
	,_timeInForce CHAR(2)
	,_execInst TEXT
	,_expiryDate TIMESTAMP WITH TIME ZONE

	,_executedQuantity BIGINT
	,_executedValue DECIMAL

	,_contraOrderId BIGINT
	) RETURNS VOID AS $$
BEGIN
	INSERT INTO phist.OrderAudit (OrderID, SequenceNumber, Version, EntityID, OwnerID, SymbolVersionID, EventDate, ExecType, Status, Created, Updated, Price, Quantity, MinQuantity, Market, Currency, TimeInForce, ExecInst, ExpiryDate, ExecutedQuantity, ExecutedValue, ContraOrderID)
		SELECT	_orderId, _sequenceNumber, _version, OW.EntityID, OD.OwnerID, _symbolVersionId, _eventDate, 'T', _status, _created, _updated, _price, _quantity, _minquantity, _market, _currency, _timeInForce, _execInst, _expiryDate, _executedQuantity, _executedValue, _contraOrderID
		FROM	phist.Order OD
				JOIN phist.Owner OW ON OD.OwnerID = OW.OwnerID
		WHERE	OD.OrderID = _orderId
		ON CONFLICT DO NOTHING; -- Allow multiple archivers to work concurrently
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.OrderAuditGetByEntity(_entityId INTEGER, _fromDate TIMESTAMP WITH TIME ZONE, _toDate TIMESTAMP WITH TIME ZONE, _count INTEGER, _isAscending BOOLEAN)
	RETURNS TABLE (
	 Version BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,ExecType CHAR(1)
	,OrderID BIGINT
	,Status CHAR(1)

	,MarketCode VARCHAR(16)
	,SymbolCode VARCHAR(16)

	,Created TIMESTAMP WITH TIME ZONE
	,Updated TIMESTAMP WITH TIME ZONE

	,Side CHAR(1)
	,Price DECIMAL
	,Quantity BIGINT
	,MinQuantity BIGINT
	,Market VARCHAR(16)

	,Currency VARCHAR(8)
	,TimeInForce CHAR(2)
	,ExecInst TEXT
	,ExpiryDate TIMESTAMP WITH TIME ZONE
	
	,ExecutedQuantity BIGINT
	,ExecutedValue DECIMAL

	,TradeID BIGINT
	,TradePrice DECIMAL
	,TradeQuantity BIGINT
	,TradeMarket VARCHAR(16)
	,Aggressor BOOLEAN

	,EntityCode VARCHAR(16)
	,OwnerContext TEXT
	,ClientContext TEXT
	) AS $$
BEGIN
	IF _isAscending THEN
		RETURN QUERY
		SELECT	AW.Version, AW.EventDate, AW.ExecType, AW.DepthOrderID, AW.Status,
				AW.MarketCode, AW.SymbolCode, AW.Created, AW.Updated,
				AW.Side, AW.Price, AW.Quantity, AW.MinQuantity, AW.Market,
				AW.Currency, AW.TimeInForce, AW.ExecInst, AW.ExpiryDate, AW.ExecutedQuantity, AW.ExecutedValue,
				AW.TradeID, AW.TradePrice, AW.TradeQuantity, AW.TradeMarket, AW.Aggressor,
				AW.EntityCode, AW.OwnerContext, AW.ClientContext
		FROM	phist.OrderAuditWithContext AW
		WHERE	AW.EntityID = _entityId
				AND (_fromDate IS NULL OR AW.EventDate >= _fromDate) AND (_toDate IS NULL OR AW.EventDate <= _toDate)
		ORDER BY AW.EventDate ASC
		FETCH NEXT (_count) ROWS ONLY;
	ELSE
		RETURN QUERY
		SELECT	AW.Version, AW.EventDate, AW.ExecType, AW.DepthOrderID, AW.Status,
				AW.MarketCode, AW.SymbolCode, AW.Created, AW.Updated,
				AW.Side, AW.Price, AW.Quantity, AW.MinQuantity, AW.Market,
				AW.Currency, AW.TimeInForce, AW.ExecInst, AW.ExpiryDate, AW.ExecutedQuantity, AW.ExecutedValue,
				AW.TradeID, AW.TradePrice, AW.TradeQuantity, AW.TradeMarket, AW.Aggressor,
				AW.EntityCode, AW.OwnerContext, AW.ClientContext
		FROM	phist.OrderAuditWithContext AW
		WHERE	AW.EntityID = _entityId
				AND (_fromDate IS NULL OR AW.EventDate >= _fromDate) AND (_toDate IS NULL OR AW.EventDate <= _toDate)
		ORDER BY AW.EventDate DESC
		FETCH NEXT (_count) ROWS ONLY;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.OrderAuditGetByOwner(_ownerId INTEGER, _fromDate TIMESTAMP WITH TIME ZONE, _toDate TIMESTAMP WITH TIME ZONE, _count INTEGER, _isAscending BOOLEAN)
	RETURNS TABLE (
	 Version BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,ExecType CHAR(1)
	,OrderID BIGINT
	,Status CHAR(1)

	,MarketCode VARCHAR(16)
	,SymbolCode VARCHAR(16)

	,Created TIMESTAMP WITH TIME ZONE
	,Updated TIMESTAMP WITH TIME ZONE

	,Side CHAR(1)
	,Price DECIMAL
	,Quantity BIGINT
	,MinQuantity BIGINT
	,Market VARCHAR(16)

	,Currency VARCHAR(8)
	,TimeInForce CHAR(2)
	,ExecInst TEXT
	,ExpiryDate TIMESTAMP WITH TIME ZONE
	
	,ExecutedQuantity BIGINT
	,ExecutedValue DECIMAL

	,TradeID BIGINT
	,TradePrice DECIMAL
	,TradeQuantity BIGINT
	,TradeMarket VARCHAR(16)
	,Aggressor BOOLEAN

	,EntityCode VARCHAR(16)
	,OwnerContext TEXT
	,ClientContext TEXT
	) AS $$
BEGIN
	IF _isAscending THEN
		RETURN QUERY
		SELECT	AW.Version, AW.EventDate, AW.ExecType, AW.DepthOrderID, AW.Status,
				AW.MarketCode, AW.SymbolCode, AW.Created, AW.Updated,
				AW.Side, AW.Price, AW.Quantity, AW.MinQuantity, AW.Market,
				AW.Currency, AW.TimeInForce, AW.ExecInst, AW.ExpiryDate, AW.ExecutedQuantity, AW.ExecutedValue,
				AW.TradeID, AW.TradePrice, AW.TradeQuantity, AW.TradeMarket, AW.Aggressor,
				AW.EntityCode, AW.OwnerContext, AW.ClientContext
		FROM	phist.OrderAuditWithContext AW
		WHERE	AW.OwnerID = _ownerId
				AND (_fromDate IS NULL OR AW.EventDate >= _fromDate) AND (_toDate IS NULL OR AW.EventDate <= _toDate)
		ORDER BY AW.EventDate ASC
		FETCH NEXT (_count) ROWS ONLY;
	ELSE
		RETURN QUERY
		SELECT	AW.Version, AW.EventDate, AW.ExecType, AW.DepthOrderID, AW.Status,
				AW.MarketCode, AW.SymbolCode, AW.Created, AW.Updated,
				AW.Side, AW.Price, AW.Quantity, AW.MinQuantity, AW.Market,
				AW.Currency, AW.TimeInForce, AW.ExecInst, AW.ExpiryDate, AW.ExecutedQuantity, AW.ExecutedValue,
				AW.TradeID, AW.TradePrice, AW.TradeQuantity, AW.TradeMarket, AW.Aggressor,
				AW.EntityCode, AW.OwnerContext, AW.ClientContext
		FROM	phist.OrderAuditWithContext AW
		WHERE	AW.OwnerID = _ownerId
				AND (_fromDate IS NULL OR AW.EventDate >= _fromDate) AND (_toDate IS NULL OR AW.EventDate <= _toDate)
		ORDER BY AW.EventDate DESC
		FETCH NEXT (_count) ROWS ONLY;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.OwnerEnsureExists(_entityId INTEGER, _code VARCHAR) RETURNS BIGINT AS $$
DECLARE
	_OwnerID BIGINT;
BEGIN
	LOOP
		SELECT	OW.OwnerID INTO _OwnerID
		FROM	phist.Owner OW
		WHERE	OW.EntityID = _entityId AND OW.Code = _code;

		EXIT WHEN FOUND;

		INSERT INTO phist.Owner (EntityID, Code)
		VALUES      (_entityId, _code)
		ON CONFLICT (EntityID, Code) DO NOTHING
		RETURNING   OwnerID INTO _OwnerID;

		EXIT WHEN FOUND;
	END LOOP;

	RETURN _OwnerID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.OwnerGet(_entityId INTEGER, _code VARCHAR) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT	OW.OwnerID
		FROM	phist.Owner OW
		WHERE	OW.EntityID = _entityId AND OW.Code = _code
		);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.RoundToHour(_timestamp TIMESTAMP WITH TIME ZONE, _roundTo INTEGER) RETURNS TIMESTAMP WITH TIME ZONE AS $$
	-- Truncate to the nearest hour, then subtract the required number of hours to round to the required precision
	SELECT DATE_TRUNC('HOUR', _timestamp) - (EXTRACT(HOUR FROM _timestamp)::INTEGER % _roundTo) * INTERVAL '1 HOUR'
$$ LANGUAGE SQL IMMUTABLE;

CREATE OR REPLACE FUNCTION phist.RoundToMinute(_timestamp TIMESTAMP WITH TIME ZONE, _roundTo INTEGER) RETURNS TIMESTAMP WITH TIME ZONE AS $$
	-- Truncate to the nearest minute, then subtract the required number of minutes to round to the required precision
	SELECT DATE_TRUNC('MINUTE', _timestamp) - (EXTRACT(MINUTE FROM _timestamp)::INTEGER % _roundTo) * INTERVAL '1 MINUTE'
$$ LANGUAGE SQL IMMUTABLE;

CREATE OR REPLACE FUNCTION phist.RoundToWeek(_timestamp TIMESTAMP WITH TIME ZONE, _roundTo INTEGER) RETURNS TIMESTAMP WITH TIME ZONE AS $$
	-- DATE_TRUNC will round down to the nearest Sunday, which is fine for one-week intervals,
	-- but if we round using EXTRACT(WEEK FROM x) it breaks since the count restarts each year.
	-- This will cause the first interval of each year to start at the wrong time, resulting in the last interval of each year having the wrong number of days included.
	-- Instead, we calculate the number of days since the first Sunday in 1901, then round down to the nearest week interval
	SELECT DATE_TRUNC('DAY', _timestamp) - (EXTRACT(DAY FROM _timestamp - DATE '1901-01-06')::INTEGER % (7 * _roundTo)) * INTERVAL '1 DAY'
$$ LANGUAGE SQL IMMUTABLE;

/*
-- If we really need it, we can use the following function to replace the % operator above, which will allow dates to be specified before the origin
CREATE OR REPLACE FUNCTION phist.RoundToDays(_days INTEGER, _roundTo INTEGER) RETURNS INTEGER AS $$
	SELECT	CASE WHEN _days >= 0 THEN _days % _roundTo ELSE _roundTo + (_days % _roundTo) END
$$ LANGUAGE SQL IMMUTABLE;
*/

CREATE OR REPLACE FUNCTION phist.SymbolCreate(_marketId INTEGER, _marketSymbolId BIGINT, _sequenceNumber BIGINT, _code VARCHAR)
	RETURNS TABLE (
		 SymbolID BIGINT
		,SymbolVersionID BIGINT
	)  AS $$
DECLARE
	_symbolID BIGINT;
	_symbolVersionID BIGINT;
BEGIN
	LOOP
		-- Check if we already have a symbol record for this Symbol
		SELECT	SY.SymbolID, SV.SymbolVersionID INTO _symbolID, _symbolVersionID
		FROM	phist.Symbol SY
				JOIN phist.SymbolVersion SV ON SY.SymbolID = SV.SymbolID
		WHERE	SY.MarketID = _marketId AND SY.MarketSymbolID = _marketSymbolId AND (SV.EndSequenceNumber IS NULL OR SV.EndSequenceNumber > _sequenceNumber);

		EXIT WHEN FOUND;

		-- Attempt to register the new symbol record
		INSERT INTO phist.Symbol (MarketID, MarketSymbolID)
			VALUES (_marketId, _marketSymbolId)
			ON CONFLICT DO NOTHING
			RETURNING Symbol.SymbolID INTO _symbolID;

		IF FOUND THEN
			-- Success, attempt to register the version
			INSERT INTO phist.SymbolVersion (SymbolID, StartSequenceNumber, Code)
				VALUES (_symbolID, _sequenceNumber, _code)
				RETURNING SymbolVersion.SymbolVersionID INTO _symbolVersionID;

			EXIT WHEN FOUND;
		END IF;
	END LOOP;

	RETURN QUERY
	SELECT	_symbolID, _symbolVersionID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.SymbolDelete(_symbolId BIGINT, _sequenceNumber BIGINT) RETURNS VOID AS $$
BEGIN
	-- Marks the Symbol as deleted.
	-- It will no longer be returned from procedures like MarketGetSecurities, SecurityGetSnapshot, etc
	UPDATE	phist.Symbol
	SET		IsDeleted = TRUE
	WHERE	SymbolID = _symbolId;

	UPDATE	phist.SymbolVersion
	SET		EndSequenceNumber = _sequenceNumber
	WHERE	SymbolID = _symbolId AND EndSequenceNumber IS NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.SymbolGetByCode(_market VARCHAR, _code VARCHAR)
	RETURNS TABLE (
		 SymbolID BIGINT
		,SymbolVersionID BIGINT
	)  AS $$
BEGIN
	RETURN QUERY
	SELECT	SY.SymbolID, SV.SymbolVersionID
	FROM	phist.Market MA
			JOIN phist.Symbol SY ON MA.MarketID = SY.MarketID
			JOIN phist.SymbolVersion SV ON SY.SymbolID = SV.SymbolID
	WHERE	MA.Code = _market AND SV.Code = _code AND SV.EndSequenceNumber IS NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.SymbolGetByID(_marketId INTEGER, _marketSymbolId BIGINT)
	RETURNS TABLE (
		 SymbolID BIGINT
		,SymbolVersionID BIGINT
	)  AS $$
BEGIN
	RETURN QUERY
	SELECT	SY.SymbolID, SV.SymbolVersionID
	FROM	phist.Symbol SY
			JOIN phist.SymbolVersion SV ON SY.SymbolID = SV.SymbolID
	WHERE	SY.MarketID = _marketId AND SY.MarketSymbolID = _marketSymbolId AND SV.EndSequenceNumber IS NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.SymbolRename(_symbolId BIGINT, _sequenceNumber BIGINT, _code VARCHAR) RETURNS BIGINT AS $$
DECLARE
	_symbolVersionID BIGINT;
BEGIN
	SELECT	SV.SymbolVersionID INTO _symbolVersionID
	FROM	phist.SymbolVersion SV
	WHERE	SV.SymbolID = _symbolId AND SV.StartSequenceNumber = _sequenceNumber;

	IF _symbolVersionID IS NOT NULL THEN
		-- Already recorded this rename
		RETURN _symbolVersionID;
	END IF;

	UPDATE	phist.SymbolVersion
	SET		EndSequenceNumber = _sequenceNumber
	WHERE	SymbolID = _symbolId AND EndSequenceNumber IS NULL;

	INSERT INTO phist.SymbolVersion (SymbolID, StartSequenceNumber, Code)
		VALUES (_symbolId, _sequenceNumber, _code)
		RETURNING SymbolVersionID INTO _symbolVersionID;

	RETURN _symbolVersionID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.TradeAdd(
	 _symbolVersionId BIGINT
	,_sequenceNumber BIGINT

	,_tradeId BIGINT
	,_eventDate TIMESTAMP WITH TIME ZONE
	,_price DECIMAL
	,_quantity BIGINT
	,_aggressor CHAR(1)
	,_market VARCHAR(16)
	,_statistics VARCHAR(8)
	,_status CHAR(1)

	,_buyOrderId BIGINT
	,_sellOrderId BIGINT
	) RETURNS VOID AS $$
BEGIN
	INSERT INTO phist.Trade (SymbolVersionID, SequenceNumber, TradeID, EventDate, Price, Quantity, Aggressor, Market, Statistics, Status, BuyOrderID, SellOrderID)
		VALUES (_symbolVersionId, _sequenceNumber, _tradeId, _eventDate, _price, _quantity, _aggressor, _market, _statistics, _status, _buyOrderId, _sellOrderId)
		ON CONFLICT DO NOTHING; -- Allow multiple archivers to work concurrently
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.TradeGetAll(_symbolId BIGINT, _fromSequenceNumber BIGINT, _toSequenceNumber BIGINT, _fromDate TIMESTAMP WITH TIME ZONE, _toDate TIMESTAMP WITH TIME ZONE, _count INTEGER, _isAscending BOOLEAN)
	RETURNS TABLE (
	 SequenceNumber BIGINT
	,Code VARCHAR(16)

	,TradeID BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,Price DECIMAL
	,Quantity BIGINT
	,Aggressor CHAR(1)
	,Market VARCHAR(16)
	,Statistics VARCHAR(8)
	,Status CHAR(1)

	,BuyOrderID BIGINT
	,BuyEntityCode VARCHAR(16)
	,BuyOwnerContext TEXT
	,BuyClientContext TEXT

	,SellOrderID BIGINT
	,SellEntityCode VARCHAR(16)
	,SellOwnerContext TEXT
	,SellClientContext TEXT
	) AS $$
BEGIN
	IF _isAscending = TRUE THEN
		RETURN QUERY
		SELECT	TW.SequenceNumber, TW.Code, TW.TradeID, TW.EventDate, TW.Price, TW.Quantity, TW.Aggressor, TW.Market, TW.Statistics, TW.Status,
				TW.BuyOrderID, TW.BuyEntityCode, TW.BuyOwnerContext, TW.BuyClientContext,
				TW.SellOrderID, TW.SellEntityCode, TW.SellOwnerContext, TW.SellClientContext
		FROM	phist.TradeWithOrders TW
		WHERE	TW.SymbolID = _symbolId
				AND (_fromSequenceNumber IS NULL OR TW.SequenceNumber >= _fromSequenceNumber) AND (_toSequenceNumber IS NULL OR TW.SequenceNumber <= _toSequenceNumber)
				AND (_fromDate IS NULL OR TW.EventDate >= _fromDate) AND (_toDate IS NULL OR TW.EventDate <= _toDate)
		ORDER BY TW.SequenceNumber ASC
		FETCH NEXT (_count) ROWS ONLY;
	ELSE
		RETURN QUERY
		SELECT	TW.SequenceNumber, TW.Code, TW.TradeID, TW.EventDate, TW.Price, TW.Quantity, TW.Aggressor, TW.Market, TW.Statistics, TW.Status,
				TW.BuyOrderID, TW.BuyEntityCode, TW.BuyOwnerContext, TW.BuyClientContext,
				TW.SellOrderID, TW.SellEntityCode, TW.SellOwnerContext, TW.SellClientContext
		FROM	phist.TradeWithOrders TW
		WHERE	TW.SymbolID = _symbolId
				AND (_fromSequenceNumber IS NULL OR TW.SequenceNumber >= _fromSequenceNumber) AND (_toSequenceNumber IS NULL OR TW.SequenceNumber <= _toSequenceNumber)
				AND (_fromDate IS NULL OR TW.EventDate >= _fromDate) AND (_toDate IS NULL OR TW.EventDate <= _toDate)
		ORDER BY TW.SequenceNumber DESC
		FETCH NEXT (_count) ROWS ONLY;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION phist.TradeGetChart(_symbolId BIGINT, _from TIMESTAMP WITH TIME ZONE, _to TIMESTAMP WITH TIME ZONE, _count INTEGER, _interval INTEGER, _isAscending BOOLEAN)
	RETURNS TABLE (
	 RecordDate TIMESTAMP WITH TIME ZONE
	,OpeningPrice DECIMAL
	,HighPrice DECIMAL
	,LowPrice DECIMAL
	,ClosingPrice DECIMAL
	
	,NumberOfTrades INTEGER
	,Volume BIGINT
	) AS $$
DECLARE
	_PartitionBy TEXT;
	_OrderByDirection TEXT;
BEGIN
	_OrderByDirection := CASE WHEN _isAscending = TRUE THEN 'ASC' ELSE 'DESC' END;

	IF _interval < 60 THEN
		IF 60 % _interval != 0 THEN
			RAISE EXCEPTION 'Interval (%) does not divide evenly into 60 minutes', _interval;
		END IF;

		_PartitionBy := 'RoundToMinute(TR.EventDate, $1)';
	ELSIF _interval < 60 * 24 THEN
		IF _interval % 60 != 0 THEN
			RAISE EXCEPTION 'Interval (%) is not a multiple of one hour', _interval;
		END IF;

		_interval := _interval / 60;

		IF 24 % _interval != 0 THEN
			RAISE EXCEPTION 'Interval (%) does not divide evenly into 24 hours', _interval;
		END IF;

		_PartitionBy := 'RoundToHour(TR.EventDate, $1)';
	ELSE
		IF _interval % (60 * 24) != 0 THEN
			RAISE EXCEPTION 'Interval (%) is not a multiple of one day', _interval;
		END IF;

		_interval := _interval / (60 * 24);

		IF _interval = 1 THEN
			_PartitionBy := 'DATE_TRUNC(''DAY'', TR.EventDate)';
		ELSIF _interval = 7 THEN
			_PartitionBy := 'DATE_TRUNC(''WEEK'', TR.EventDate)';
		ELSIF _interval = 30 THEN
			_PartitionBy := 'DATE_TRUNC(''MONTH'', TR.EventDate)';
		ELSIF _interval = 90 THEN
			_PartitionBy := 'DATE_TRUNC(''QUARTER'', TR.EventDate)';
		ELSIF _interval = 365 THEN
			_PartitionBy := 'DATE_TRUNC(''YEAR'', TR.EventDate)';
		ELSIF _interval % 7 = 0 THEN
			-- Support for fortnights and larger week intervals
			_interval := _interval / 7;

			_PartitionBy := 'RoundToWeek(TR.EventDate, $1)';
		ELSE
			RAISE EXCEPTION 'Interval (%) is not a valid day value', _interval;
		END IF;
	END IF;

	RETURN QUERY EXECUTE FORMAT($A$
		SELECT	GD.RecordDate, GD.OpeningPrice, GD.HighPrice, GD.LowPrice, GD.ClosingPrice, GD.NumberOfTrades, GD.Volume
		FROM	(
				SELECT	 %1$s AS RecordDate
						,FIRST_VALUE(TR.Price) OVER Candle AS OpeningPrice
						,MAX(TR.Price)         OVER Candle AS HighPrice
						,MIN(TR.Price)         OVER Candle AS LowPrice
						,LAST_VALUE(TR.Price)  OVER Candle AS ClosingPrice
						,(COUNT(*)             OVER Candle)::INT AS NumberOfTrades
						,(SUM(TR.Quantity)     OVER Candle)::BIGINT AS Volume
						,ROW_NUMBER()          OVER (PARTITION BY %1$s ORDER BY TR.EventDate DESC) AS RowNumber
				FROM	phist.Trade TR
						JOIN phist.SymbolVersion SV ON TR.SymbolVersionID = SV.SymbolVersionID
				WHERE	SV.SymbolID = $2 AND ($3 IS NULL OR $3 <= TR.EventDate) AND ($4 IS NULL OR $4 >= TR.EventDate)
						AND TR.Statistics = 'APV' -- Ignore trades that don't affect statistics
				WINDOW	Candle AS (PARTITION BY %1$s ORDER BY TR.EventDate)
				) GD
		WHERE	GD.RowNumber = 1
		ORDER BY GD.RecordDate %2$s
		FETCH FIRST ($5) ROWS ONLY;
		$A$,
		_PartitionBy,
		_OrderByDirection
		) USING _interval, _symbolId, _from, _to, _count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.CheckpointCreate(_marketId INTEGER, _effectiveDate TIMESTAMP WITH TIME ZONE, _minimumTime INTEGER) RETURNS BIGINT AS $$
DECLARE
	_latestCheckpoint TIMESTAMP WITH TIME ZONE;
	
	_sequenceNumber BIGINT;
	_checkpointId BIGINT;
BEGIN
	SELECT	MAX(MC.CheckpointDate) INTO _latestCheckpoint
	FROM	prodigy.MarketCheckpoint MC
	WHERE	MC.MarketID = _marketId;
	
	-- Ensure the most recent Checkpoint isn't sooner than the minimum time
	IF _latestCheckpoint IS NOT NULL AND _latestCheckpoint + make_interval(secs => _minimumTime) > _effectiveDate THEN
		RETURN NULL;
	END IF;

	-- Find the earliest Market Sequence Number used by a Security Snapshot before the checkpoint
	SELECT	MIN(MSN.MarketSequenceNumber) INTO _sequenceNumber
	FROM	(
			SELECT	ROW_NUMBER() OVER (PARTITION BY SS.SymbolID ORDER BY SS.SequenceNumber DESC) AS RowNumber, SS.MarketSequenceNumber
			FROM	prodigy.SecuritySnapshot SS
					JOIN prodigy.Symbol SY ON SY.SymbolID = SS.SymbolID
			WHERE	SY.MarketID = _marketId AND SY.DeletedAt IS NULL
			) MSN
	WHERE	MSN.RowNumber = 1;

	-- We're potentially competing with another process, so make sure only one succeeds
	LOOP
		SELECT	MC.MarketCheckpointID INTO _checkpointId
		FROM	prodigy.MarketCheckpoint MC
		WHERE	MC.MarketID = _marketId AND MC.CheckpointDate = _effectiveDate;
		
		EXIT WHEN FOUND;

		-- Attempt to create the Checkpoint and get the Checkpoint ID, storing the Sequence Number of the most recent Market Snapshot needed for restoring our Securities
		INSERT INTO prodigy.MarketCheckpoint (MarketID, SequenceNumber, CheckpointDate)
			SELECT	_marketId, MAX(MS.SequenceNumber), _effectiveDate
			FROM	prodigy.MarketSnapshot MS
			WHERE	MS.MarketID = _marketId AND MS.SequenceNumber <= _sequenceNumber
			ON CONFLICT DO NOTHING
			RETURNING MarketCheckpointID INTO _checkpointId;
		
		IF FOUND THEN
			-- Success, get the most recent Snapshot Sequence Number for each active Symbol
			INSERT INTO prodigy.MarketCheckpointSecurity (MarketCheckpointID, SymbolID, SequenceNumber)
				SELECT	_checkpointId, SS.SymbolID, MAX(SS.SequenceNumber)
				FROM	prodigy.SecuritySnapshot SS
						JOIN prodigy.Symbol SY ON SY.SymbolID = SS.SymbolID
				WHERE	SY.MarketID = _marketId AND SY.DeletedAt IS NULL
				GROUP BY SS.SymbolID;

			EXIT;
		END IF;

	END LOOP;

	RETURN _checkpointId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.CheckpointGet(_marketId INTEGER) RETURNS BIGINT AS $$
BEGIN
	RETURN	(
			SELECT	MC.MarketCheckpointID
			FROM	prodigy.MarketCheckpoint MC
			WHERE	MC.MarketID = _marketID
			ORDER BY MC.CheckpointDate DESC
			FETCH FIRST 1 ROW ONLY
			);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.CheckpointGetBefore(_marketId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS BIGINT AS $$
BEGIN
	RETURN	(
			SELECT	MC.MarketCheckpointID
			FROM	prodigy.MarketCheckpoint MC
			WHERE	MC.MarketID = _marketId AND CheckpointDate <= _timestamp
			ORDER BY MC.CheckpointDate DESC
			FETCH FIRST 1 ROW ONLY
			);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.CheckpointGetMarket(_checkpointId BIGINT)
	RETURNS TABLE (
	 SequenceNumber BIGINT
	,SnapshotDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	-- Return the Snapshot associated with this Checkpoint
	RETURN QUERY
	SELECT	MS.SequenceNumber, MS.SnapshotDate, MS.Data
	FROM	prodigy.MarketCheckpoint MC
			JOIN prodigy.MarketSnapshot MS ON MS.MarketID = MC.MarketID AND MS.SequenceNumber = MC.SequenceNumber
	WHERE	MC.MarketCheckpointID = _checkpointId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.CheckpointGetSecurityEvents(_checkpointId BIGINT)
	RETURNS TABLE (
	 MarketSymbolID INTEGER
	,Code VARCHAR(16)
	,MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,EventType VARCHAR(32)
	,Data BYTEA
	) AS $$
BEGIN
	-- Return all events after the Checkpoint for each Symbol
	RETURN QUERY
	SELECT  CE.MarketSymbolID, CE.Code, CE.MarketSequenceNumber, CE.SequenceNumber, CE.EventDate, CE.EventType, CE.Data
	FROM	(
			-- For each symbol mentioned in the checkpoint, grab the events afterwards
			SELECT	SY.MarketSymbolID, SY.Code, SE.MarketSequenceNumber, SE.SequenceNumber, SE.EventDate, SE.EventType, SE.Data
			FROM	prodigy.MarketCheckpointSecurity CS
					JOIN prodigy.SecurityEvent SE ON SE.SymbolID = CS.SymbolID
					JOIN prodigy.Symbol SY ON SY.SymbolID = CS.SymbolID
			WHERE	CS.MarketCheckpointID = _checkpointId AND SE.SequenceNumber > CS.SequenceNumber
			UNION ALL
			-- For each symbol NOT mentioned in the checkpoint, which existed at some point after the checkpoint, return ALL their events
			SELECT	SY.MarketSymbolID, SY.Code, SE.MarketSequenceNumber, SE.SequenceNumber, SE.EventDate, SE.EventType, SE.Data
			FROM	prodigy.MarketCheckpoint CK
					JOIN prodigy.Symbol SY ON CK.MarketID = SY.MarketID
					JOIN prodigy.SecurityEvent SE ON SE.SymbolID = SY.SymbolID
			WHERE	CK.MarketCheckpointID = _checkpointId AND (SY.DeletedAt IS NULL OR SY.DeletedAt < CK.SequenceNumber)
					AND SY.SymbolID NOT IN (SELECT SymbolID FROM prodigy.MarketCheckpointSecurity WHERE MarketCheckpointID = _checkpointId)
			) CE
	-- We order by Market Sequence Number, then Sequence Number, so we can interleave the Market Events with the output
	ORDER BY CE.MarketSequenceNumber ASC, CE.SequenceNumber ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.CheckpointGetSecurityEventsOrdered(_checkpointId BIGINT)
	RETURNS TABLE (
	 MarketSymbolID INTEGER
	,Code VARCHAR(16)
	,MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,EventType VARCHAR(32)
	,Data BYTEA
	) AS $$
BEGIN
	-- Return all events after the Checkpoint for each Symbol
	RETURN QUERY
	SELECT  CE.MarketSymbolID, CE.Code, CE.MarketSequenceNumber, CE.SequenceNumber, CE.EventDate, CE.EventType, CE.Data
	FROM	(
			-- For each symbol mentioned in the checkpoint, grab the events afterwards
			SELECT	SY.MarketSymbolID, SY.Code, SE.MarketSequenceNumber, SE.SequenceNumber, SE.EventDate, SE.EventType, SE.Data
			FROM	prodigy.MarketCheckpointSecurity CS
					JOIN prodigy.SecurityEvent SE ON SE.SymbolID = CS.SymbolID
					JOIN prodigy.Symbol SY ON SY.SymbolID = CS.SymbolID
			WHERE	CS.MarketCheckpointID = _checkpointId AND SE.SequenceNumber > CS.SequenceNumber
			UNION ALL
			-- For each symbol NOT mentioned in the checkpoint, which existed at some point after the checkpoint, return ALL their events
			SELECT	SY.MarketSymbolID, SY.Code, SE.MarketSequenceNumber, SE.SequenceNumber, SE.EventDate, SE.EventType, SE.Data
			FROM	prodigy.MarketCheckpoint CK
					JOIN prodigy.Symbol SY ON CK.MarketID = SY.MarketID
					JOIN prodigy.SecurityEvent SE ON SE.SymbolID = SY.SymbolID
			WHERE	CK.MarketCheckpointID = _checkpointId AND (SY.DeletedAt IS NULL OR SY.DeletedAt < CK.SequenceNumber)
					AND SY.SymbolID NOT IN (SELECT SymbolID FROM prodigy.MarketCheckpointSecurity WHERE MarketCheckpointID = _checkpointId)
			) CE
	-- We order by Market Sequence Number, then Sequence Number, so we can interleave the Market Events with the output
	ORDER BY CE.MarketSequenceNumber ASC, CE.SequenceNumber ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.CheckpointGetSecuritySnapshots(_checkpointId BIGINT)
	RETURNS TABLE (
	 MarketSymbolID INTEGER
	,Code VARCHAR(16)
	,MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,SnapshotDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	-- Retrieve all the Security Snapshots associated with the given Checkpoint
	SELECT	SY.MarketSymbolID, SY.Code, SS.MarketSequenceNumber, SS.SequenceNumber, SS.SnapshotDate, SS.Data
	FROM	prodigy.MarketCheckpointSecurity CS
			JOIN prodigy.SecuritySnapshot SS ON SS.SymbolID = CS.SymbolID
			JOIN prodigy.Symbol SY ON SY.SymbolID = SS.SymbolID
	WHERE	CS.MarketCheckpointID = _checkpointId AND SS.SequenceNumber = CS.SequenceNumber;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketCreate(_code VARCHAR, _setup BYTEA, _config BYTEA, _comments TEXT) RETURNS INTEGER AS $$
DECLARE
	_marketID INTEGER;
BEGIN
	IF EXISTS (SELECT 1 FROM prodigy.Market WHERE Code = _code AND IsDeleted = FALSE) THEN
		RETURN NULL;
	END IF;

	WITH MarketInsert AS (
		INSERT INTO prodigy.Market (Code, Comments)
			VALUES (_code, _comments)
			RETURNING MarketID
	)
	INSERT INTO prodigy.MarketSetup (MarketID, SequenceNumber, Setup, Config)
		SELECT	MarketID, 1, _setup, _config
		FROM	MarketInsert
		RETURNING MarketSetup.MarketID INTO _marketID;

	RETURN _marketID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketCreateEvent(_marketId INTEGER, _sequenceNumber BIGINT, _eventType VARCHAR(32), _data BYTEA)
	RETURNS TIMESTAMP WITH TIME ZONE AS $$
DECLARE
	_eventDate TIMESTAMP WITH TIME ZONE;
BEGIN
	INSERT INTO prodigy.MarketEvent (MarketID, SequenceNumber, EventType, Data)
		VALUES (_marketId, _sequenceNumber, _eventType, _data)
		RETURNING MarketEvent.EventDate INTO _eventDate;

	RETURN _eventDate;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketCreateSnapshot(_marketId INTEGER, _sequenceNumber BIGINT, _eventDate TIMESTAMP WITH TIME ZONE, _data BYTEA) RETURNS VOID AS $$
BEGIN
	INSERT INTO prodigy.MarketSnapshot (MarketID, SequenceNumber, SnapshotDate, Data)
		VALUES (_marketId, _sequenceNumber, _eventDate, _data)
		ON CONFLICT DO NOTHING;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketDelete(_code VARCHAR) RETURNS BOOLEAN AS $$
DECLARE
	_marketID INTEGER;
BEGIN
	SELECT	MA.MarketID INTO _marketID
	FROM	prodigy.Market MA
	WHERE	MA.Code = _code AND MA.IsDeleted = FALSE;

	IF _marketID IS NULL THEN
		RETURN FALSE;
	END IF;

	-- Marks the Market as deleted.
	-- It will no longer be returned from procedures like MarketGetAll, etc
	UPDATE	prodigy.Market
	SET		IsDeleted = TRUE
	WHERE	MarketID = _marketID;

	RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGet(_code VARCHAR)
	RETURNS TABLE (
	 MarketID INTEGER
	,Code VARCHAR(16)
	,Comments TEXT
	) AS $$
BEGIN
	-- Retrieves some information about a specific market code
	RETURN QUERY
	SELECT  MA.MarketID, MA.Code, MA.Comments
	FROM    prodigy.Market MA
	WHERE   MA.Code = _code AND MA.IsDeleted = FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGetAll(_startIndex INTEGER, _count INTEGER)
	RETURNS TABLE (
	 Code VARCHAR(16)
	,Setup BYTEA
	,Config BYTEA
	,Comments TEXT
	) AS $$
BEGIN
	-- Retrieve the most recent Market Setup for every active Market
	-- Used for market listings in the REST API
	RETURN QUERY
	SELECT	MK.Code, MK.Setup, MK.Config, MK.Comments
	FROM	(
			SELECT	ROW_NUMBER() OVER (PARTITION BY MA.MarketID ORDER BY MS.SequenceNumber DESC) AS RowNumber, MA.Code, MS.Setup, MS.Config, MA.Comments
			FROM	prodigy.Market MA
					JOIN prodigy.MarketSetup MS ON MA.MarketID = MS.MarketID
			WHERE	MA.IsDeleted = FALSE
			) MK
	WHERE	MK.RowNumber = 1
	ORDER BY MK.Code ASC
	OFFSET (_startIndex) FETCH NEXT (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGetEvents(_marketId INTEGER, _sequenceNumber BIGINT)
	RETURNS TABLE (
	 SequenceNumber BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,EventType VARCHAR(32)
	,Data BYTEA
	) AS $$
BEGIN
	-- Retrieves the market events after a specific sequence number
	-- Used when restoring a Market
	RETURN QUERY
	SELECT	ME.SequenceNumber, ME.EventDate, ME.EventType, ME.Data
	FROM	prodigy.MarketEvent ME
	WHERE	ME.MarketID = _marketId AND ME.SequenceNumber > _sequenceNumber
	ORDER BY ME.SequenceNumber ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGetSecurityEvents(_marketId INTEGER)
	RETURNS TABLE (
	 MarketSymbolID INTEGER
	,Code VARCHAR(16)
	,MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,EventType VARCHAR(32)
	,Data BYTEA
	) AS $$
BEGIN
	-- Retrieves all events (including the first) for all symbols for a Market
	-- Used when initialising from the start of the Market history
	RETURN QUERY
	SELECT	SY.MarketSymbolID, SY.Code, SE.MarketSequenceNumber, SE.SequenceNumber, SE.EventDate, SE.EventType, SE.Data
	FROM	prodigy.Symbol SY
			JOIN prodigy.SecurityEvent SE ON SY.SymbolID = SE.SymbolID
	WHERE	SY.MarketID = _marketID
	-- We order by Symbol ID and then Sequence Number, so we ensure that symbols deleted and re-added with the same code get returned in the correct order
	ORDER BY SY.SymbolID ASC, SE.SequenceNumber ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGetSecurityEventsOrdered(_marketId INTEGER)
	RETURNS TABLE (
	 MarketSymbolID INTEGER
	,Code VARCHAR(16)
	,MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,EventType VARCHAR(32)
	,Data BYTEA
	) AS $$
BEGIN
	-- Retrieves all events (including the first) for all symbols for a Market
	-- Used when replaying from the start of the Market history
	RETURN QUERY
	SELECT	SY.MarketSymbolID, SY.Code, SE.MarketSequenceNumber, SE.SequenceNumber, SE.EventDate, SE.EventType, SE.Data
	FROM	prodigy.Symbol SY
			JOIN prodigy.SecurityEvent SE ON SY.SymbolID = SE.SymbolID
	WHERE	SY.MarketID = _marketID
	-- We order by Market Sequence Number, then Sequence Number, so we can interleave the Market Events with the output
	ORDER BY SE.MarketSequenceNumber ASC, SE.SequenceNumber ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGetSetup(_marketId INTEGER)
	RETURNS TABLE (
	 SequenceNumber BIGINT
	,Setup BYTEA
	,Config BYTEA
	) AS $$
BEGIN
	-- Get the latest Market Setup (defines the assemblies and types used)
	-- Used when restoring any sort of Market structure
	RETURN QUERY
	SELECT	MS.SequenceNumber, MS.Setup, MS.Config
	FROM	prodigy.MarketSetup MS
	WHERE	MS.MarketID = _marketId
	ORDER BY MS.SequenceNumber DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGetSnapshot(_marketId INTEGER)
	RETURNS TABLE (
	 SequenceNumber BIGINT
	,SnapshotDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	-- Get the latest Market Snapshot
	-- Used when restoring the latest Market by itself
	RETURN QUERY
	SELECT	MS.SequenceNumber, MS.SnapshotDate, MS.Data
	FROM	prodigy.MarketSnapshot MS
	WHERE	MS.MarketID = _marketId
	ORDER BY MS.SequenceNumber DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGetSnapshotBefore(_marketId INTEGER, _sequenceNumber BIGINT)
	RETURNS TABLE (
	 SequenceNumber BIGINT
	,SnapshotDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	-- Get the most recent Market Snapshot on or before the target sequence number
	-- Used when restoring one or more securities
	RETURN QUERY
	SELECT	MS.SequenceNumber, MS.SnapshotDate, MS.Data
	FROM	prodigy.MarketSnapshot MS
	WHERE	MS.MarketID = _marketId AND MS.SequenceNumber <= _sequenceNumber
	ORDER BY MS.SequenceNumber DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketGetSymbol(_marketId INTEGER, _code VARCHAR) RETURNS INTEGER AS $$
BEGIN
	-- Gets the active identifier for a symbol code on a Market
	RETURN (
		SELECT	SY.SymbolID
		FROM	prodigy.Symbol SY
		WHERE	SY.MarketID = _marketId AND SY.Code = _code AND SY.DeletedAt IS NULL
		);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.MarketUpdateConfig(_marketId INTEGER, _sequenceNumber BIGINT, _config BYTEA, _comments TEXT) RETURNS BOOLEAN AS $$
DECLARE
	_previousSequenceNumber BIGINT;
BEGIN
	-- Find the most recent Market Setup, so we can copy its setup
	SELECT  MAX(MS.SequenceNumber) INTO _previousSequenceNumber
	FROM    prodigy.MarketSetup MS
	WHERE   MS.MarketID = _marketId;

	INSERT INTO prodigy.MarketSetup (MarketID, SequenceNumber, Setup, Config)
		SELECT  MarketID, _sequenceNumber, Setup, _config
		FROM    prodigy.MarketSetup MS
		WHERE   MS.MarketID = _marketId AND MS.SequenceNumber = _sequenceNumber;

	UPDATE  prodigy.Market
	SET     Comments = _comments
	WHERE   MarketID = _marketId;

	RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.OperationCleanup(_age INTERVAL) RETURNS VOID AS $$
DECLARE
	_thresholdDate TIMESTAMP;
BEGIN
	SELECT CURRENT_TIMESTAMP - _age INTO _thresholdDate;
	
	DELETE
	FROM	prodigy.Operation
	WHERE	ProcessedDate > _thresholdDate;
END
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.OperationCreate(_messageKey TEXT, _messageID UUID)
	RETURNS TABLE (
		ProcessedDate TIMESTAMP WITH TIME ZONE
		) AS $$
BEGIN
	RETURN QUERY
	INSERT INTO prodigy.Operation (MessageKey, MessageID, ProcessedDate)
		VALUES (_messageKey, _messageID, CURRENT_TIMESTAMP)
		RETURNING Operation.ProcessedDate;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.OperationGet(_messageKey TEXT, _age INTERVAL)
	RETURNS TABLE (
		MessageID UUID,
		ProcessedDate TIMESTAMP WITH TIME ZONE
		) AS $$
DECLARE
	_thresholdDate TIMESTAMP;
BEGIN
	SELECT CURRENT_TIMESTAMP - _age INTO _thresholdDate;
	
	RETURN QUERY
	SELECT	PO.MessageID, PO.ProcessedDate
	FROM	prodigy.Operation PO
	WHERE	PO.MessageKey = _messageKey AND PO.ProcessedDate > _thresholdDate;	
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SecurityCreateEvent(_symbolId INTEGER, _marketSequenceNumber BIGINT, _sequenceNumber BIGINT, _eventType VARCHAR(32), _data BYTEA) RETURNS TIMESTAMP WITH TIME ZONE AS $$
DECLARE
	_eventDate TIMESTAMP WITH TIME ZONE;
BEGIN
	INSERT INTO prodigy.SecurityEvent (SymbolID, MarketSequenceNumber, SequenceNumber, EventType, Data)
		VALUES (_symbolId, _marketSequenceNumber, _sequenceNumber, _eventType, _data)
		RETURNING SecurityEvent.EventDate INTO _eventDate;

	RETURN _eventDate;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SecurityCreateSnapshot(_symbolId INTEGER, _marketSequenceNumber BIGINT, _sequenceNumber BIGINT, _eventDate TIMESTAMP WITH TIME ZONE, _data BYTEA) RETURNS VOID AS $$
BEGIN
	INSERT INTO prodigy.SecuritySnapshot (SymbolID, MarketSequenceNumber, SequenceNumber, SnapshotDate, Data)
		VALUES (_symbolId, _marketSequenceNumber, _sequenceNumber, _eventDate, _data)
		ON CONFLICT DO NOTHING;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SecurityGetEvents(_symbolId INTEGER, _sequenceNumber BIGINT)
	RETURNS TABLE (
	 MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	,EventType VARCHAR(32)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	SE.MarketSequenceNumber, SE.SequenceNumber, SE.EventDate, SE.EventType, SE.Data
	FROM	prodigy.SecurityEvent SE
	WHERE	SE.SymbolID = _symbolId AND SE.SequenceNumber > _sequenceNumber
	ORDER BY SE.SequenceNumber ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SecurityGetSnapshot(_symbolId INTEGER)
	RETURNS TABLE (
	 MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,SnapshotDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	-- Get the latest Security Snapshot
	-- Used when restoring the latest state of a Security
	RETURN QUERY
	SELECT	SS.MarketSequenceNumber, SS.SequenceNumber, SS.SnapshotDate, SS.Data
	FROM	prodigy.SecuritySnapshot SS
	WHERE	SS.SymbolID = _symbolId
	ORDER BY SS.SequenceNumber DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SecurityGetSnapshotBefore(_symbolId INTEGER, _sequenceNumber BIGINT)
	RETURNS TABLE (
	 MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,SnapshotDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	-- Get the latest Security Snapshot before a specific Sequence Number
	-- Used when replaying the history of a Security
	RETURN QUERY
	SELECT	SS.MarketSequenceNumber, SS.SequenceNumber, SS.SnapshotDate, SS.Data
	FROM	prodigy.SecuritySnapshot SS
	WHERE	SS.SymbolID = _symbolId AND SS.SequenceNumber < _sequenceNumber
	ORDER BY SS.SequenceNumber DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SecurityGetSnapshotBefore(_symbolId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE)
	RETURNS TABLE (
	 MarketSequenceNumber BIGINT
	,SequenceNumber BIGINT
	,SnapshotDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	-- Get the latest Security Snapshot before a specific timestamp
	-- Used when replaying the history of a Security
	RETURN QUERY
	SELECT	SS.MarketSequenceNumber, SS.SequenceNumber, SS.SnapshotDate, SS.Data
	FROM	prodigy.SecuritySnapshot SS
	WHERE	SS.SymbolID = _symbolId AND SS.SnapshotDate < _timestamp
	ORDER BY SS.SequenceNumber DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SymbolCreate(_marketId INTEGER, _marketSymbolID INTEGER, _code VARCHAR, _marketSequenceNumber BIGINT, _data BYTEA, _comments TEXT) RETURNS INTEGER AS $$
DECLARE
	_symbolID INTEGER;
BEGIN
	SELECT	SY.SymbolID INTO _symbolID
	FROM	prodigy.Symbol SY
	WHERE	SY.MarketID = _marketId AND SY.Code = _code AND SY.DeletedAt IS NULL;

	IF _symbolID IS NOT NULL THEN
		RAISE EXCEPTION 'Symbol (%) already exists', _code USING ERRCODE = 'unique_violation';

		RETURN 0;
	END IF;

	INSERT INTO prodigy.Symbol (MarketID, MarketSymbolID, Code, Comments)
		VALUES (_marketId, _marketSymbolID, _code, _comments)
		RETURNING SymbolID INTO _symbolID;

	INSERT INTO prodigy.SymbolSetup (SymbolID, SequenceNumber, Data)
		VALUES (_symbolID, _marketSequenceNumber, _data);

	RETURN _symbolID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SymbolDelete(_symbolId INTEGER, _marketSequenceNumber BIGINT, _comments TEXT) RETURNS VOID AS $$
BEGIN
	-- Marks the Symbol as deleted from this event onward.
	-- It will no longer be returned from procedures like SymbolGetAll, SecurityGetSnapshot, etc
	UPDATE	prodigy.Symbol
	SET		DeletedAt = _marketSequenceNumber,
			Comments = _comments
	WHERE	SymbolID = _symbolId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SymbolGet(_market VARCHAR, _code VARCHAR)
	RETURNS TABLE (
	 MarketCode VARCHAR(16)
	,MarketSymbolID INTEGER
	,Code VARCHAR(16)
	,SequenceNumber BIGINT
	,SetupDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	,Comments TEXT
	) AS $$
BEGIN
	-- Gets the latest Symbol Snapshot
	-- Used for symbol listings in the REST API
	RETURN QUERY
	SELECT	MA.Code, SY.MarketSymbolID, SY.Code, SS.SequenceNumber, SS.SetupDate, SS.Data, SY.Comments
	FROM	prodigy.Market MA
			JOIN prodigy.Symbol SY ON MA.MarketID = SY.MarketID
			JOIN prodigy.SymbolSetup SS ON SY.SymbolID = SS.SymbolID
	WHERE	MA.Code = _market AND SY.Code = _code AND SY.DeletedAt IS NULL
	ORDER BY SS.SequenceNumber DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SymbolGetAll(_code VARCHAR, _startIndex INTEGER, _count INTEGER)
	RETURNS TABLE (
	 MarketCode VARCHAR(16)
	,Code VARCHAR(16)
	,SequenceNumber BIGINT
	,SetupDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	,Comments TEXT
	) AS $$
BEGIN
	RETURN QUERY
	-- Retrieve the most recent Symbol Setup for every active Symbol
	-- Used for symbol listings in the REST API
	SELECT	AL.MarketCode, AL.Code, AL.SequenceNumber, AL.SetupDate, AL.Data, AL.Comments
	FROM	(
			SELECT	ROW_NUMBER() OVER (PARTITION BY SY.SymbolID ORDER BY SS.SequenceNumber DESC) AS RowNumber, MA.Code AS MarketCode, SY.Code,
					SS.SequenceNumber, SS.SetupDate, SS.Data, SY.Comments
			FROM	prodigy.Market MA
					JOIN prodigy.Symbol SY ON MA.MarketID = SY.MarketID
					JOIN prodigy.SymbolSetup SS ON SY.SymbolID = SS.SymbolID
			WHERE	MA.Code = _code AND SY.DeletedAt IS NULL
			) AL
	WHERE	AL.RowNumber = 1
	ORDER BY AL.Code ASC
	OFFSET (_startIndex) FETCH NEXT (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SymbolGetByID(_market VARCHAR, _marketSymbolId VARCHAR)
	RETURNS TABLE (
	 MarketCode VARCHAR(16)
	,MarketSymbolID INTEGER
	,Code VARCHAR(16)
	,SequenceNumber BIGINT
	,SetupDate TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	,Comments TEXT
	) AS $$
BEGIN
	-- Gets the latest Symbol Snapshot
	-- Used for symbol listings in the REST API
	RETURN QUERY
	SELECT	MA.Code, SY.MarketSymbolID, SY.Code, SS.SequenceNumber, SS.SetupDate, SS.Data, SY.Comments
	FROM	prodigy.Market MA
			JOIN prodigy.Symbol SY ON MA.MarketID = SY.MarketID
			JOIN prodigy.SymbolSetup SS ON SY.SymbolID = SS.SymbolID
	WHERE	MA.Code = _market AND SY.MarketSymbolID = _marketSymbolId
	ORDER BY SS.SequenceNumber DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION prodigy.SymbolUpdate(_symbolId INTEGER, _code VARCHAR, _marketSequenceNumber BIGINT, _data BYTEA, _comments TEXT) RETURNS VOID AS $$
DECLARE
	_OtherSymbolID INTEGER;
BEGIN
	-- Ensure any code changes are unique
	SELECT  SY.SymbolID INTO _OtherSymbolID
	FROM    prodigy.Symbol SY
	WHERE   SY.MarketID = (SELECT MarketID FROM prodigy.Symbol WHERE SymbolID = _symbolId)
	        AND SY.Code = _code AND SY.DeletedAt IS NULL AND SY.SymbolID != _symbolId;

	IF _OtherSymbolID IS NOT NULL THEN
		RAISE EXCEPTION 'Symbol (%) already exists', _code USING ERRCODE = 'unique_violation';

		RETURN;
	END IF;

	UPDATE	prodigy.Symbol
	SET		Code = _code, Comments = _comments
	WHERE	SymbolID = _symbolId;
	
	INSERT INTO prodigy.SymbolSetup (SymbolID, SequenceNumber, Data)
		VALUES (_symbolId, _marketSequenceNumber, _data);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMIT TRANSACTION;
