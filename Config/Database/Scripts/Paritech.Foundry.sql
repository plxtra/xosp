BEGIN TRANSACTION;
CREATE SCHEMA foundry;

CREATE TABLE IF NOT EXISTS foundry.Source (
	 SourceID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,Code VARCHAR(16) NOT NULL

	,CONSTRAINT PkSource PRIMARY KEY (SourceID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqSourceCode ON foundry.Source (Code);

CREATE TABLE IF NOT EXISTS foundry.Feed (
	 FeedID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,SourceID INTEGER NOT NULL
	,Code TEXT NOT NULL

	,CONSTRAINT PkFeed PRIMARY KEY (FeedID)
);

CREATE UNIQUE INDEX IF NOT EXISTS UqFeedSourceCode ON foundry.Feed (SourceID, Code);

CREATE TABLE IF NOT EXISTS foundry.Snapshot (
	 SnapshotID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,SourceID INTEGER NOT NULL
	,Type CHAR(2) NOT NULL

	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL
	,ExpiredBy INTEGER

	,Data BYTEA NOT NULL

	,CONSTRAINT PkSnapshot PRIMARY KEY (SnapshotID)
);

-- Index for looking up active snapshots
CREATE INDEX IF NOT EXISTS UqSnapshotSourceTypeUpdate ON foundry.Snapshot (SourceID, Type) WHERE (ExpiredBy IS NULL);

-- Index for looking up active snapshots by the date they were added
CREATE INDEX IF NOT EXISTS IxSnapshotSourceTypeDate ON foundry.Snapshot (SourceID, Type, EventDate) WHERE (ExpiredBy IS NULL);

-- Index for looking up expired snapshots by the snapshot that expired them (so we can reactivate them when it's removed)
CREATE INDEX IF NOT EXISTS UqSnapshotSourceTypeExpiredBy ON foundry.Snapshot (SourceID, Type, ExpiredBy) WHERE (ExpiredBy IS NOT NULL);

CREATE TABLE IF NOT EXISTS foundry.SnapshotSequence (
	 SnapshotID INTEGER NOT NULL
	,FeedID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL

	,CONSTRAINT PkSnapshotSequence PRIMARY KEY (SnapshotID, FeedID)
);

CREATE TABLE IF NOT EXISTS foundry.Update (
	 SourceID INTEGER NOT NULL
	,FeedID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL

	,Type CHAR(2) NOT NULL
	,EventDate TIMESTAMP WITH TIME ZONE NOT NULL CONSTRAINT DfUpdateEventDate DEFAULT CURRENT_TIMESTAMP

	,Data BYTEA NOT NULL
	,Metadata BYTEA NOT NULL

	,CONSTRAINT PkUpdate PRIMARY KEY (SourceID, FeedID, SequenceNumber)
);

CREATE INDEX IF NOT EXISTS IxUpdateSourceFeedDate ON foundry.Update (SourceID, FeedID, EventDate);

CREATE TABLE IF NOT EXISTS foundry.Asset (
	 SourceID INTEGER NOT NULL
	,AssetID BIGINT NOT NULL
	,Version INTEGER NOT NULL

	,Data BYTEA NOT NULL

	,CONSTRAINT PkAsset PRIMARY KEY (SourceID, AssetID, Version)
);

CREATE TABLE IF NOT EXISTS foundry.Entity (
	 SourceID INTEGER NOT NULL
	,EntityID BIGINT NOT NULL
	,Version INTEGER NOT NULL

	,Data BYTEA NOT NULL

	,CONSTRAINT PkEntity PRIMARY KEY (SourceID, EntityID, Version)
);

CREATE TABLE IF NOT EXISTS foundry.Execution (
	 SourceID INTEGER NOT NULL
	,ExecutionID BIGINT NOT NULL

	,Code TEXT NOT NULL
	,Timestamp TIMESTAMP WITH TIME ZONE NOT NULL

	,Data BYTEA NOT NULL

	,CONSTRAINT PkExecution PRIMARY KEY (SourceID, ExecutionID)
);

CREATE INDEX IF NOT EXISTS IxExecutionSourceTimestamp ON foundry.Execution (SourceID, Timestamp, ExecutionID);

CREATE TABLE IF NOT EXISTS foundry.ExecutionSequence (
	 SourceID INTEGER NOT NULL
	,ExecutionID BIGINT NOT NULL
	,FeedID INTEGER NOT NULL
	,SequenceNumber BIGINT NOT NULL

	,CONSTRAINT PkExecutionSequence PRIMARY KEY (SourceID, ExecutionID, FeedID)
);

CREATE TABLE IF NOT EXISTS foundry.Ledger (
	 SourceID INTEGER NOT NULL
	,LedgerID BIGINT NOT NULL
	,Version INTEGER NOT NULL

	,Data BYTEA NOT NULL

	,CONSTRAINT PkLedger PRIMARY KEY (SourceID, LedgerID, Version)
);

CREATE TABLE IF NOT EXISTS foundry.Report (
	 SourceID INTEGER NOT NULL
	,ReportID BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,EntityID BIGINT NOT NULL
	,Code TEXT NOT NULL
	,Type TEXT NOT NULL
	,Timestamp TIMESTAMP WITH TIME ZONE NOT NULL
	,Description TEXT

	,Data BYTEA NOT NULL

	,CONSTRAINT PkReport PRIMARY KEY (SourceID, ReportID)
);

CREATE INDEX IF NOT EXISTS IxReportSourceTimestamp ON foundry.Report (SourceID, Timestamp, ReportID);

CREATE TABLE IF NOT EXISTS foundry.Transaction (
	 SourceID INTEGER NOT NULL
	,ExecutionID BIGINT NOT NULL
	,EntryID INTEGER NOT NULL

	,Code TEXT NOT NULL
	,Amount NUMERIC NOT NULL

	,AssetID BIGINT NOT NULL
	,AssetVersion INTEGER NOT NULL
	,DebitLedgerID BIGINT NOT NULL
	,DebitLedgerVersion INTEGER NOT NULL
	,DebitEntityID BIGINT NOT NULL
	,DebitEntityVersion INTEGER NOT NULL
	,DebitBalance NUMERIC NOT NULL
	,CreditLedgerID BIGINT NOT NULL
	,CreditLedgerVersion INTEGER NOT NULL
	,CreditEntityID BIGINT NOT NULL
	,CreditEntityVersion INTEGER NOT NULL
	,CreditBalance NUMERIC NOT NULL

	,CONSTRAINT PkTransaction PRIMARY KEY (SourceID, ExecutionID, EntryID)
);

CREATE INDEX IF NOT EXISTS IxTransactionCodeExecution ON foundry.Transaction (SourceID, Code, ExecutionID);

CREATE INDEX IF NOT EXISTS IxTransactionAssetExecution ON foundry.Transaction (SourceID, AssetID, ExecutionID);

CREATE INDEX IF NOT EXISTS IxTransactionCreditEntityExecution ON foundry.Transaction (SourceID, CreditEntityID, ExecutionID);

CREATE INDEX IF NOT EXISTS IxTransactionDebitEntityExecution ON foundry.Transaction (SourceID, DebitEntityID, ExecutionID);

CREATE INDEX IF NOT EXISTS IxTransactionCreditLedgerExecution ON foundry.Transaction (SourceID, CreditLedgerID, ExecutionID);

CREATE INDEX IF NOT EXISTS IxTransactionDebitLedgerExecution ON foundry.Transaction (SourceID, DebitLedgerID, ExecutionID);

ALTER TABLE ONLY foundry.SnapshotSequence
	ADD CONSTRAINT FkSnapshotSequenceSnapshot FOREIGN KEY (SnapshotID) REFERENCES foundry.Snapshot (SnapshotID) ON DELETE CASCADE;

ALTER TABLE ONLY foundry.Snapshot
	ADD CONSTRAINT FkSnapshotSource FOREIGN KEY (SourceID) REFERENCES foundry.Source (SourceID);

ALTER TABLE ONLY foundry.Update
	ADD CONSTRAINT FkUpdateSource FOREIGN KEY (SourceID) REFERENCES foundry.Source (SourceID);

ALTER TABLE ONLY foundry.Asset
	ADD CONSTRAINT FkAssetSource FOREIGN KEY (SourceID)
	REFERENCES foundry.Source (SourceID);

ALTER TABLE ONLY foundry.Entity
	ADD CONSTRAINT FkEntitySource FOREIGN KEY (SourceID)
	REFERENCES foundry.Source (SourceID);

ALTER TABLE ONLY foundry.ExecutionSequence
	ADD CONSTRAINT FkExecutionSequenceExecution FOREIGN KEY (SourceID, ExecutionID)
	REFERENCES foundry.Execution (SourceID, ExecutionID);

ALTER TABLE ONLY foundry.Execution
	ADD CONSTRAINT FkExecutionSource FOREIGN KEY (SourceID)
	REFERENCES foundry.Source (SourceID);

ALTER TABLE ONLY foundry.Ledger
	ADD CONSTRAINT FkLedgerSource FOREIGN KEY (SourceID)
	REFERENCES foundry.Source (SourceID);

ALTER TABLE ONLY foundry.Report
	ADD CONSTRAINT FkReportSource FOREIGN KEY (SourceID)
	REFERENCES foundry.Source (SourceID);

ALTER TABLE ONLY foundry.Transaction
	ADD CONSTRAINT FkTransactionAsset FOREIGN KEY (SourceID, AssetID, AssetVersion)
	REFERENCES foundry.Asset (SourceID, AssetID, Version);

ALTER TABLE ONLY foundry.Transaction
	ADD CONSTRAINT FkTransactionEntityDebit FOREIGN KEY (SourceID, DebitEntityID, DebitEntityVersion)
	REFERENCES foundry.Entity (SourceID, EntityID, Version);

ALTER TABLE ONLY foundry.Transaction
	ADD CONSTRAINT FkTransactionEntityCredit FOREIGN KEY (SourceID, CreditEntityID, CreditEntityVersion)
	REFERENCES foundry.Entity (SourceID, EntityID, Version);

ALTER TABLE ONLY foundry.Transaction
	ADD CONSTRAINT FkTransactionExecution FOREIGN KEY (SourceID, ExecutionID)
	REFERENCES foundry.Execution (SourceID, ExecutionID);

ALTER TABLE ONLY foundry.Transaction
	ADD CONSTRAINT FkTransactionLedgerDebit FOREIGN KEY (SourceID, DebitLedgerID, DebitLedgerVersion)
	REFERENCES foundry.Ledger (SourceID, LedgerID, Version);

ALTER TABLE ONLY foundry.Transaction
	ADD CONSTRAINT FkTransactionLedgerCredit FOREIGN KEY (SourceID, CreditLedgerID, CreditLedgerVersion)
	REFERENCES foundry.Ledger (SourceID, LedgerID, Version);

CREATE OR REPLACE VIEW foundry.SnapshotMetadata AS
	SELECT	SnapshotID, SourceID, Type, EventDate, ExpiredBy, FeedID, SequenceNumber
	FROM	foundry.Snapshot SS
			JOIN foundry.SnapshotSequence SQ USING (SnapshotID);

CREATE OR REPLACE FUNCTION foundry.SourceEnsureExists (_code VARCHAR(16)) RETURNS INTEGER AS $$
DECLARE
	_SourceID BIGINT;
BEGIN
	LOOP
		SELECT	SO.SourceID INTO _SourceID
		FROM	foundry.Source SO
		WHERE	SO.Code = _code;

		EXIT WHEN FOUND;
		
		INSERT INTO foundry.Source (Code)
		VALUES      (_code)
		ON CONFLICT DO NOTHING
		RETURNING SourceID INTO _SourceID;

		EXIT WHEN FOUND;
	END LOOP;

	RETURN _SourceID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.FeedEnsureExists (_sourceId INTEGER, _code VARCHAR(16)) RETURNS INTEGER AS $$
DECLARE
	_FeedID BIGINT;
BEGIN
	LOOP
		SELECT	FE.FeedID INTO _FeedID
		FROM	foundry.Feed FE
		WHERE	FE.SourceID = _sourceId AND FE.Code = _code;

		EXIT WHEN FOUND;

		INSERT INTO foundry.Feed (SourceID, Code)
		VALUES      (_sourceId, _code)
		ON CONFLICT (SourceID, Code) DO NOTHING
		RETURNING FeedID INTO _FeedID;

		EXIT WHEN FOUND;
	END LOOP;

	RETURN _FeedID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.SnapshotCreate(_sourceId INTEGER, _eventdate TIMESTAMP WITH TIME ZONE, _type CHAR(2), _data BYTEA, _feedIds INTEGER[], _sequenceNumbers BIGINT[]) RETURNS INTEGER AS $$
DECLARE
	_SnapshotID INTEGER;
BEGIN
	INSERT INTO foundry.Snapshot (SourceID, Type, EventDate, Data)
	    VALUES (_sourceId, _type, _eventdate, _data)
	    RETURNING SnapshotID INTO _SnapshotID;

	INSERT INTO foundry.SnapshotSequence(SnapshotID, FeedID, SequenceNumber)
	    SELECT  _SnapshotID, FS.FeedID, FS.SequenceNumber
	    FROM    UNNEST(_feedIds, _sequenceNumbers) AS FS(FeedID, SequenceNumber);

	-- Expire snapshots based on date, which should be the timestamp of the most recent update included in this snapshot
	UPDATE  foundry.Snapshot
	SET     ExpiredBy = _SnapshotID
	WHERE   SnapshotID != _SnapshotID AND SourceID = _sourceID AND Type = _type AND EventDate >= _eventdate AND ExpiredBy IS NULL;

	RETURN _SnapshotID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.SnapshotDelete(_sourceId INTEGER, _type CHAR(2), _snapshotId INTEGER) RETURNS VOID AS $$
DECLARE
	_ExpiredBy INTEGER;
BEGIN
	-- Ensure we're removing the correct Snapshot
	SELECT  SN.ExpiredBy INTO _ExpiredBy
	FROM    foundry.Snapshot SN
	WHERE   SN.SnapshotID = _snapshotId AND SN.SourceID = _sourceId AND SN.Type = _type;

	IF NOT FOUND THEN
		RETURN;
	END IF;

	-- Remove this Snapshot
	DELETE
	FROM    foundry.SnapshotSequence
	WHERE   SnapshotID = _snapshotId;

	DELETE
	FROM    foundry.Snapshot
	WHERE   SnapshotID = _snapshotId;

	-- Any previous Snapshots that were expired by the addition of this Snapshot should now be either reactivated, or marked as expired by the Snapshot that expired us
	UPDATE  oms.Snapshot
	SET     ExpiredBy = _ExpiredBy
	WHERE	SourceID = _sourceId AND Type = _type AND ExpiredBy = _snapshotId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.SnapshotGet(_snapshotId INTEGER) RETURNS TABLE (
	 SnapshotID INTEGER
	,EventDate TIMESTAMP WITH TIME ZONE
	,Type CHAR(2)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  SS.SnapshotID, SS.EventDate, SS.Type, SS.Data
	FROM	foundry.Snapshot SS
	WHERE   SS.SnapshotID = _snapshotId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.SnapshotGetBefore(_sourceId INTEGER, _type CHAR(2), _feedIds INTEGER[], _sequenceNumbers BIGINT[]) RETURNS TABLE (
	 SnapshotID INTEGER
	,EventDate TIMESTAMP WITH TIME ZONE
	,Type CHAR(2)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  SS.SnapshotID, SS.EventDate, SS.Type, SS.Data
	FROM    foundry.Snapshot SS
	WHERE   SS.SourceID = _sourceId AND SS.Type = _type AND ExpiredBy IS NULL AND NOT EXISTS (
	    SELECT  1
	    FROM    foundry.SnapshotSequence SQ
	            LEFT JOIN UNNEST(_feedIds, _sequenceNumbers) AS FSU(FeedID, SequenceNumber) USING (FeedID)
	    WHERE   SS.SnapshotID = SQ.SnapshotID AND (FSU.SequenceNumber IS NULL OR FSU.SequenceNumber < SQ.SequenceNumber)
	)
	ORDER BY EventDate DESC, SnapshotID DESC
	FETCH FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.SnapshotGetLatest(_sourceId INTEGER, _type CHAR(2)) RETURNS TABLE (
	 SnapshotID INTEGER
	,EventDate TIMESTAMP WITH TIME ZONE
	,Type CHAR(2)
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  SS.SnapshotID, SS.EventDate, SS.Type, SS.Data
	FROM	foundry.Snapshot SS
	WHERE   SS.SourceID = _sourceId AND SS.Type = _type AND ExpiredBy IS NULL
	ORDER BY SnapshotID DESC
	FETCH   FIRST 1 ROW ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.SnapshotGetPositions(_snapshotId INTEGER) RETURNS TABLE (
	 FeedID INTEGER
	,FeedCode VARCHAR(16)
	,SequenceNumber BIGINT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  SQ.FeedID, FE.Code, SQ.SequenceNumber
	FROM	foundry.SnapshotSequence SQ
	        JOIN foundry.Feed FE ON (SQ.FeedID = FE.FeedID)
	WHERE   SQ.SnapshotID = _snapshotId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.UpdateCreate(_sourceId INTEGER, _feedId INTEGER, _sequenceNumber BIGINT, _type CHAR(2), _data BYTEA, _metadata BYTEA) RETURNS VOID AS $$
BEGIN
	INSERT INTO foundry.Update (SourceID, FeedID, SequenceNumber, Type, Data, Metadata)
		VALUES (_sourceId, _feedId, _sequenceNumber, _type, _data, _metadata);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.UpdateCreate(_sourceId INTEGER, _feedId INTEGER, _sequenceNumber BIGINT, _eventdate TIMESTAMP WITH TIME ZONE, _type CHAR(2), _data BYTEA, _metadata BYTEA) RETURNS VOID AS $$
BEGIN
	-- This function is specifically for imports and migrations. UpdateGetPositions relies on EventDate increasing within a Feed
	-- When using this function, callers must ensure the dates supplied are always increasing.
	INSERT INTO foundry.Update (SourceID, FeedID, SequenceNumber, EventDate, Type, Data, Metadata)
		VALUES (_sourceId, _feedId, _sequenceNumber, _eventdate, _type, _data, _metadata);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.UpdateGetAfter(_sourceId INTEGER, _fromFeedIds INTEGER[], _fromSequenceNumbers BIGINT[], _count INTEGER) RETURNS TABLE (
	 FeedID INTEGER
	,SequenceNumber BIGINT
	,FeedCode TEXT

	,Type CHAR(2)
	,EventDate TIMESTAMP WITH TIME ZONE

	,Data BYTEA
	,Metadata BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  FE.FeedID, UD.SequenceNumber, FE.Code, UD.Type, UD.EventDate, UD.Data, UD.Metadata
	FROM    foundry.Update UD
	        JOIN foundry.Feed FE USING (FeedID)
	        LEFT JOIN UNNEST(_fromFeedIds, _fromSequenceNumbers) AS FSL(FeedID, SequenceNumber) USING (FeedID) -- Left join, so we also get any feeds that aren't mentioned (ie: added after the reference point)
	WHERE   UD.SourceID = _sourceId AND (FSL.SequenceNumber IS NULL OR UD.SequenceNumber > FSL.SequenceNumber)
	ORDER BY EventDate ASC, FeedID ASC, SequenceNumber ASC
	FETCH   FIRST (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.UpdateGetBetween(_sourceId INTEGER, _fromFeedIds INTEGER[], _fromSequenceNumbers BIGINT[], _toFeedIds INTEGER[], _toSequenceNumbers BIGINT[], _count INTEGER) RETURNS TABLE (
	 FeedID INTEGER
	,SequenceNumber BIGINT
	,FeedCode TEXT

	,Type CHAR(2)
	,EventDate TIMESTAMP WITH TIME ZONE

	,Data BYTEA
	,Metadata BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  FE.FeedID, UD.SequenceNumber, FE.Code, UD.Type, UD.EventDate, UD.Data, UD.Metadata
	FROM    foundry.Update UD
	        JOIN foundry.Feed FE USING (FeedID)
	        JOIN UNNEST(_toFeedIds, _toSequenceNumbers) AS FSU(FeedID, SequenceNumber) USING (FeedID) -- Full join, since to should be a superset of from
	        LEFT JOIN UNNEST(_fromFeedIds, _fromSequenceNumbers) AS FSL(FeedID, SequenceNumber) USING (FeedID) -- Left join, so we also get any feeds that aren't mentioned (ie: added after the reference point)
	WHERE   UD.SourceID = _sourceId AND UD.SequenceNumber <= FSU.SequenceNumber AND (FSL.SequenceNumber IS NULL OR UD.SequenceNumber > FSL.SequenceNumber)
	ORDER BY EventDate ASC, FeedID ASC, SequenceNumber ASC
	FETCH   FIRST (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.UpdateGetFeedAsAt(_sourceId INTEGER, _feedId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  MAX(UD.SequenceNumber)
		FROM	foundry.Update UD
		WHERE   UD.SourceID = _sourceId AND UD.FeedID = _feedId AND UD.EventDate < _timestamp
	);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.UpdateGetForFeed(_sourceId INTEGER, _feedId INTEGER, _sequenceNumber BIGINT) RETURNS TABLE (
	 SequenceNumber BIGINT

	,Type CHAR(2)
	,EventDate TIMESTAMP WITH TIME ZONE

	,Data BYTEA
	,Metadata BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  UD.SequenceNumber, UD.Type, UD.EventDate, UD.Data, UD.Metadata
	FROM	foundry.Update UD
	WHERE   UD.SourceID = _sourceId
	        AND UD.FeedID = _feedId AND UD.SequenceNumber > _sequenceNumber
	ORDER BY SequenceNumber ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Used by adapters to replay updates previously written to a particular feed

CREATE OR REPLACE FUNCTION foundry.UpdateGetLatestForFeed(_sourceId INTEGER, _feedId INTEGER) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  MAX(UD.SequenceNumber)
		FROM	foundry.Update UD
		WHERE   UD.SourceID = _sourceId AND UD.FeedID = _feedId
	);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Used by adapters to determine the most recent Sequence Number written for a particular feed

CREATE OR REPLACE FUNCTION foundry.UpdateGetPositions(_sourceId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS TABLE (
	 FeedID INTEGER
	,FeedCode TEXT
	,SequenceNumber BIGINT
	,EventDate TIMESTAMP WITH TIME ZONE
	) AS $$
BEGIN
	-- Finds the highest sequence number for each feed before a given timestamp
	RETURN QUERY
	SELECT  FE.FeedID, FE.Code, UPR.SequenceNumber, UPR.EventDate
	FROM    (
	        SELECT  ROW_NUMBER() OVER (PARTITION BY UD.FeedID ORDER BY UD.EventDate DESC, UD.SequenceNumber DESC) AS RowNumber,
	                UD.FeedID,  UD.SequenceNumber, UD.EventDate
	        FROM    foundry.Update UD
	        WHERE   UD.SourceID = _sourceId AND UD.EventDate < _timestamp
	        ) UPR
	        JOIN foundry.Feed FE USING (FeedID)
	WHERE   RowNumber = 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.AssetEnsureExists (_sourceId INTEGER, _assetId BIGINT, _data BYTEA) RETURNS INTEGER AS $$
DECLARE
	_Version INTEGER;
BEGIN
	SELECT	COALESCE(MAX(AE.Version), 0) INTO _Version
	FROM	foundry.Asset AE
	WHERE	AE.SourceID = _sourceId AND AE.AssetID = _assetId;

	IF EXISTS (
		SELECT	1
		FROM	foundry.Asset AE
		WHERE	AE.SourceID = _sourceId AND AE.AssetID = _assetId AND AE.Version = _Version AND AE.Data = _data
		) THEN
		RETURN _Version;
	END IF;

	INSERT INTO foundry.Asset (SourceID, AssetID, Version, Data)
		VALUES  (_sourceId, _assetId, _Version + 1, _data);

	RETURN _Version + 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.AssetGet (_sourceId INTEGER, _assetId BIGINT[], _version INTEGER[])
	RETURNS TABLE (
		 ID BIGINT
		,Version INTEGER
		,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  AT.AssetID, AT.Version, AT.Data
	FROM    foundry.Asset AT
	        JOIN UNNEST(_assetId, _version) AS IDS(ID, Version) ON AT.AssetID = IDS.ID AND AT.Version = IDS.Version
	WHERE   AT.SourceID = _sourceId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.EntityEnsureExists (_sourceId INTEGER, _entityId BIGINT, _data BYTEA) RETURNS INTEGER AS $$
DECLARE
	_Version INTEGER;
BEGIN
	SELECT	COALESCE(MAX(EN.Version), 0) INTO _Version
	FROM	foundry.Entity EN
	WHERE	EN.SourceID = _sourceId AND EN.EntityID = _entityId;

	IF EXISTS (
		SELECT	1
		FROM	foundry.Entity EN
		WHERE	EN.SourceID = _sourceId AND EN.EntityID = _entityId AND EN.Version = _Version AND EN.Data = _data
		) THEN
		RETURN _Version;
	END IF;

	INSERT INTO foundry.Entity (SourceID, EntityID, Version, Data)
		VALUES  (_sourceId, _entityId, _Version + 1, _data);

	RETURN _Version + 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.EntityGet (_sourceId INTEGER, _entityId BIGINT[], _version INTEGER[])
	RETURNS TABLE (
		 ID BIGINT
		,Version INTEGER
		,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  EN.EntityID, EN.Version, EN.Data
	FROM    foundry.Entity EN
	        JOIN UNNEST(_entityId, _version) AS IDS(ID, Version) ON EN.EntityID = IDS.ID AND EN.Version = IDS.Version
	WHERE   EN.SourceID = _sourceId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ExecutionCreate(_sourceId INTEGER, _executionId BIGINT, _code TEXT, _timestamp TIMESTAMP WITH TIME ZONE, _data BYTEA, _feedIds INTEGER[], _sequenceNumbers BIGINT[]) RETURNS VOID AS $$
BEGIN
	INSERT INTO foundry.Execution (SourceID, ExecutionID, Code, Timestamp, Data)
	    VALUES (_sourceId, _executionId, _code, _timestamp, _data);

	INSERT INTO foundry.ExecutionSequence(SourceID, ExecutionID, FeedID, SequenceNumber)
	    SELECT  _sourceId, _executionId, FS.FeedID, FS.SequenceNumber
	    FROM    UNNEST(_feedIds, _sequenceNumbers) AS FS(FeedID, SequenceNumber);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ExecutionGetAfterDate(_sourceId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  MIN(EX.ExecutionID)
		FROM    foundry.Execution EX
		WHERE   EX.SourceID = _sourceId AND EX.Timestamp >= _timestamp
		);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ExecutionGetBeforeDate(_sourceId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  MAX(EX.ExecutionID)
		FROM    foundry.Execution EX
		WHERE   EX.SourceID = _sourceId AND EX.Timestamp < _timestamp
		);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ExecutionGetBeforePosition(_sourceId INTEGER, _feedIds INTEGER[], _sequenceNumbers BIGINT[]) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  MAX(EX.ExecutionID)
		FROM    foundry.Execution EX
		WHERE   EX.SourceID = _sourceId AND EX.Timestamp < _timestamp
		);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ExecutionGetByID (_sourceId INTEGER, _executionId BIGINT)
	RETURNS TABLE (
	 Code TEXT
	,"timestamp" TIMESTAMP WITH TIME ZONE

	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	EX.Code, EX.Timestamp, EX.Data
	FROM	foundry.Execution EX
	WHERE	EX.SourceID = _sourceId AND EX.ExecutionID = _executionId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ExecutionGetLatest(_sourceId INTEGER)
	RETURNS TABLE (
		 FeedID INTEGER
		,FeedCode TEXT
		,SequenceNumber BIGINT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  FE.FeedID, FE.Code, ESQ.SequenceNumber
	FROM    (
	        SELECT  MAX(EX.ExecutionID) AS ExecutionID
	        FROM    foundry.Execution EX
	        WHERE   EX.SourceID = _sourceId
	        ) MEX
	        JOIN foundry.ExecutionSequence ESQ USING (ExecutionID)
	        JOIN foundry.Feed FE USING (FeedID)
	WHERE   ESQ.SourceID = _sourceId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ExecutionSearch (
	_sourceId INTEGER,
	_fromExecutionId BIGINT, _toExecutionId BIGINT,
	_assetId BIGINT, _entityId BIGINT, _ledgerId BIGINT,
	_transCodes TEXT[],
	_execCodes TEXT[],
	_count INTEGER
	) RETURNS TABLE (
	 Code TEXT
	,"timestamp" TIMESTAMP WITH TIME ZONE
	,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT	EX.Code, EX.Timestamp, EX.Data
	FROM	foundry.Execution EX
	WHERE	EX.SourceID = _sourceId
	        AND EX.ExecutionID >= _fromExecutionId AND (_toExecutionId IS NULL OR EX.ExecutionID < _toExecutionId)
	        AND (_assetId IS NULL OR EXISTS (SELECT 1 FROM foundry.Transaction TX WHERE TX.SourceID = EX.SourceID AND TX.ExecutionID = EX.ExecutionID AND TX.AssetID = _assetId))
	        AND (_entityId IS NULL OR EXISTS (SELECT 1 FROM foundry.Transaction TX WHERE TX.SourceID = EX.SourceID AND TX.ExecutionID = EX.ExecutionID AND (TX.DebitEntityID = _entityId OR TX.CreditEntityID = _entityId)))
	        AND (_ledgerId IS NULL OR EXISTS (SELECT 1 FROM foundry.Transaction TX WHERE TX.SourceID = EX.SourceID AND TX.ExecutionID = EX.ExecutionID AND (TX.DebitLedgerID = _ledgerId OR TX.CreditLedgerID = _ledgerId)))
	        AND (_transCodes IS NULL OR EXISTS (SELECT 1 FROM foundry.Transaction TX WHERE TX.SourceID = EX.SourceID AND TX.ExecutionID = EX.ExecutionID AND TX.Code = ANY (_transCodes)))
	        AND (_execCodes IS NULL OR EX.Code = ANY (_execCodes))
	ORDER BY EX.ExecutionID ASC
	FETCH FIRST (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.LedgerEnsureExists (_sourceId INTEGER, _ledgerId BIGINT, _data BYTEA) RETURNS INTEGER AS $$
DECLARE
	_Version INTEGER;
BEGIN
	SELECT	COALESCE(MAX(LE.Version), 0) INTO _Version
	FROM	foundry.Ledger LE
	WHERE	LE.SourceID = _sourceId AND LE.LedgerID = _ledgerId;

	IF EXISTS (
		SELECT	1
		FROM	foundry.Ledger LE
		WHERE	LE.SourceID = _sourceId AND LE.LedgerID = _ledgerId AND LE.Version = _Version AND LE.Data = _data
		) THEN
		RETURN _Version;
	END IF;

	INSERT INTO foundry.Ledger (SourceID, LedgerID, Version, Data)
		VALUES  (_sourceId, _ledgerId, _Version + 1, _data);

	RETURN _Version + 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.LedgerGet (_sourceId INTEGER, _ledgerId BIGINT[], _version INTEGER[])
	RETURNS TABLE (
		 ID BIGINT
		,Version INTEGER
		,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  LE.LedgerID, LE.Version, LE.Data
	FROM    foundry.Ledger LE
	        JOIN UNNEST(_ledgerId, _version) AS IDS(ID, Version) ON LE.LedgerID = IDS.ID AND LE.Version = IDS.Version
	WHERE   LE.SourceID = _sourceId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ReportCreate(_sourceId INTEGER, _entityId BIGINT, _code TEXT, _type TEXT, _timestamp TIMESTAMP WITH TIME ZONE, _description TEXT, _data BYTEA) RETURNS BIGINT AS $$
DECLARE
	_reportId BIGINT;
BEGIN
	INSERT INTO foundry.Report (SourceID, EntityID, Code, Type, Timestamp, Description, Data)
		VALUES (_sourceId, _entityId, _code, _type, _timestamp, _description, _data)
		RETURNING ReportID INTO _reportId;

	RETURN _reportId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ReportGet(_sourceId INTEGER, _reportId BIGINT)
	RETURNS TABLE (
		 ReportID BIGINT
		,EntityID BIGINT
		,Code TEXT
		,Type TEXT
		,"timestamp" TIMESTAMP WITH TIME ZONE
		,Description TEXT
		,Data BYTEA
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  RE.ReportID, RE.EntityID, RE.Code, RE.Type, RE.Timestamp, RE.Description, RE.Data
	FROM    foundry.Report RE
	WHERE   RE.SourceID = _sourceId AND RE.ReportID = _reportId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ReportGetAfterDate(_sourceId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  MIN(RE.ReportID)
		FROM    foundry.Report RE
		WHERE   RE.SourceID = _sourceId AND RE.Timestamp >= _timestamp
		);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ReportGetBeforeDate(_sourceId INTEGER, _timestamp TIMESTAMP WITH TIME ZONE) RETURNS BIGINT AS $$
BEGIN
	RETURN (
		SELECT  MAX(RE.ReportID)
		FROM    foundry.Report RE
		WHERE   RE.SourceID = _sourceId AND RE.Timestamp < _timestamp
		);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.ReportSearch (
	_sourceId INTEGER, _entityId BIGINT,
	_fromId BIGINT, _toId BIGINT,
	_codes TEXT[], _types TEXT[], _count INTEGER
	) RETURNS TABLE (
		 ReportID BIGINT
		,EntityID BIGINT
		,Code TEXT
		,Type TEXT
		,"timestamp" TIMESTAMP WITH TIME ZONE
		,Description TEXT
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  ReportID, EntityID, Code, Type, Timestamp, Description
	FROM    foundry.Report RE
	WHERE   RE.SourceID = _sourceId AND RE.ReportID >= _fromId
	        AND (_toId IS NULL OR RE.ReportID < _toId)
	        AND (_entityId IS NULL OR RE.EntityID = _entityId)
	        AND (_codes IS NULL OR RE.Code = ANY(_codes))
	        AND (_types IS NULL OR RE.Type = ANY(_types))
	ORDER BY ReportID DESC
	FETCH FIRST (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionCreate (
	_sourceId INTEGER, _executionId BIGINT, _entryId INTEGER,
	_code TEXT, _amount NUMERIC,
	_assetID BIGINT,
	_assetVersion INTEGER,
	_debitLedgerID BIGINT,
	_debitLedgerVersion INTEGER,
	_debitEntityID BIGINT,
	_debitEntityVersion INTEGER,
	_debitBalance NUMERIC,
	_creditLedgerID BIGINT,
	_creditLedgerVersion INTEGER,
	_creditEntityID BIGINT,
	_creditEntityVersion INTEGER,
	_creditBalance NUMERIC
	) RETURNS VOID AS $$
BEGIN
	INSERT INTO foundry.Transaction (
		SourceID, ExecutionID, EntryID, Code, Amount, AssetID, AssetVersion,
		DebitLedgerID, DebitLedgerVersion, DebitEntityID, DebitEntityVersion, DebitBalance,
		CreditLedgerID, CreditLedgerVersion, CreditEntityID, CreditEntityVersion, CreditBalance
		) VALUES (
		_sourceId, _executionId, _entryId, _code, _amount, _assetID, _assetVersion,
		_debitLedgerID, _debitLedgerVersion, _debitEntityID, _debitEntityVersion, _debitBalance,
		_creditLedgerID, _creditLedgerVersion, _creditEntityID, _creditEntityVersion, _creditBalance
		);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionCreateBulk (
	_sourceId INTEGER, _executionId BIGINT,
	_code TEXT[], _amount NUMERIC[],
	_assetID BIGINT[],
	_assetVersion INTEGER[],
	_debitLedgerID BIGINT[],
	_debitLedgerVersion INTEGER[],
	_debitEntityID BIGINT[],
	_debitEntityVersion INTEGER[],
	_debitBalance NUMERIC[],
	_creditLedgerID BIGINT[],
	_creditLedgerVersion INTEGER[],
	_creditEntityID BIGINT[],
	_creditEntityVersion INTEGER[],
	_creditBalance NUMERIC[]
	) RETURNS VOID AS $$
BEGIN
	INSERT INTO foundry.Transaction (
		SourceID, ExecutionID, EntryID, Code, Amount, AssetID, AssetVersion,
		DebitLedgerID, DebitLedgerVersion, DebitEntityID, DebitEntityVersion, DebitBalance,
		CreditLedgerID, CreditLedgerVersion, CreditEntityID, CreditEntityVersion, CreditBalance
		)
		SELECT	_sourceId, _executionId, UN.Code, UN.Amount, UN.AssetID, UN.AssetVersion,
				UN.DebitLedgerID, UN.DebitLedgerVersion, UN.DebitEntityID, UN.DebitEntityVersion, UN.DebitBalance,
				UN.CreditLedgerID, UN.CreditLedgerVersion, UN.CreditEntityID, UN.CreditEntityVersion, UN.CreditBalance
		FROM	UNNEST(
					_code, _amount, _assetID, _assetVersion,
					_debitLedgerID, _debitLedgerVersion, _debitEntityID, _debitEntityVersion, _debitBalance,
					_creditLedgerID, _creditLedgerVersion, _creditEntityID, _creditEntityVersion, _creditBalance
				) AS UN(
					Code, Amount, AssetID, AssetVersion,
					DebitLedgerID, DebitLedgerVersion, DebitEntityID, DebitEntityVersion, DebitBalance,
					CreditLedgerID, CreditLedgerVersion, CreditEntityID, CreditEntityVersion, CreditBalance
				);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionGetAssets (_sourceId INTEGER, _ledgerId BIGINT, _fromExecutionId BIGINT, _toExecutionId BIGINT)
	RETURNS TABLE (AssetID BIGINT) AS $$
BEGIN
	RETURN QUERY
	SELECT	DISTINCT TR.AssetID
	FROM	foundry.Transaction TR
	WHERE	TR.SourceID = _sourceId AND (TR.CreditLedgerID = _ledgerId OR TR.DebitLedgerID = _ledgerId)
	        AND TR.ExecutionID >= _fromExecutionId AND (_toExecutionId IS NULL OR TR.ExecutionID < _toExecutionId);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionGetAssetsForEntity (_sourceId INTEGER, _ledgerId BIGINT, _entityId BIGINT, _fromExecutionId BIGINT, _toExecutionId BIGINT)
	RETURNS TABLE (AssetID BIGINT) AS $$
BEGIN
	RETURN QUERY
	SELECT	DISTINCT TR.AssetID
	FROM	foundry.Transaction TR
	WHERE	TR.SourceID = _sourceId AND (TR.CreditLedgerID = _ledgerId OR TR.DebitLedgerID = _ledgerId)
	        AND (TR.CreditEntityID = _entityId OR TR.DebitEntityID = _entityId)
	        AND TR.ExecutionID >= _fromExecutionId AND (_toExecutionId IS NULL OR TR.ExecutionID < _toExecutionId);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionGetByExecution (_sourceId INTEGER, _executionId BIGINT)
	RETURNS TABLE (
	 ExecutionID BIGINT
	,ExecutionCode TEXT
	,"timestamp" TIMESTAMP WITH TIME ZONE

	,EntryID INTEGER
	,EntryCode TEXT
	,Amount NUMERIC

	,AssetID BIGINT
	,AssetVersion INTEGER
	,DebitLedgerID BIGINT
	,DebitLedgerVersion INTEGER
	,DebitEntityID BIGINT
	,DebitEntityVersion INTEGER
	,DebitBalance NUMERIC
	,CreditLedgerID BIGINT
	,CreditLedgerVersion INTEGER
	,CreditEntityID BIGINT
	,CreditEntityVersion INTEGER
	,CreditBalance NUMERIC
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  EX.ExecutionID, EX.Code,  EX.Timestamp, TR.EntryID, TR.Code, TR.Amount,
	        TR.AssetID, TR.AssetVersion,
	        TR.DebitLedgerID, TR.DebitLedgerVersion, TR.DebitEntityID, TR.DebitEntityVersion, TR.DebitBalance,
	        TR.CreditLedgerID, TR.CreditLedgerVersion, TR.CreditEntityID, TR.CreditEntityVersion, TR.CreditBalance
	FROM    foundry.Execution EX
	        JOIN foundry.Transaction TR USING (SourceID, ExecutionID)
	WHERE   EX.SourceID = _sourceId
	        AND EX.ExecutionID = _executionId
	ORDER BY EntryID ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionGetCodes (_sourceId INTEGER)
	RETURNS TABLE (Code TEXT) AS $$
BEGIN
	RETURN QUERY
	SELECT	DISTINCT TR.Code
	FROM	foundry.Transaction TR
	WHERE	TR.SourceID = _sourceId;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionGetEntities (_sourceId INTEGER, _ledgerId BIGINT, _fromExecutionId BIGINT, _toExecutionId BIGINT)
	RETURNS TABLE (EntityID BIGINT) AS $$
BEGIN
	-- Rather than specify the conditions twice, we use a CTE
	-- According to Analyse, this will only search through the transactions once, and the matches will then be scanned for unique values in either column
	-- This is in theory better than using UNION directly on the columns, which causes two scans on the transactions table
	RETURN QUERY
	WITH Records AS (
		SELECT	TR.CreditEntityID, TR.DebitEntityID
		FROM	foundry.Transaction TR
		WHERE	TR.SourceID = _sourceId AND (TR.CreditLedgerID = _ledgerId OR TR.DebitLedgerID = _ledgerId)
		        AND TR.ExecutionID >= _fromExecutionId AND (_toExecutionId IS NULL OR TR.ExecutionID < _toExecutionId)
	)
	SELECT	CreditEntityID
	FROM	Records
	UNION
	SELECT	DebitEntityID
	FROM	Records;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionGetEntitiesForAsset (_sourceId INTEGER, _ledgerId BIGINT, _assetID BIGINT, _fromExecutionId BIGINT, _toExecutionId BIGINT)
	RETURNS TABLE (EntityID BIGINT) AS $$
BEGIN
	-- Rather than specify the conditions twice, we use a CTE
	-- According to Analyse, this will only search through the transactions once, and the matches will then be scanned for unique values in either column
	-- This is in theory better than using UNION directly on the columns, which causes two scans on the transactions table
	RETURN QUERY
	WITH Records AS (
		SELECT	TR.CreditEntityID, TR.DebitEntityID
		FROM	foundry.Transaction TR
		WHERE	TR.SourceID = _sourceId AND (TR.CreditLedgerID = _ledgerId OR TR.DebitLedgerID = _ledgerId)
		        AND TR.AssetID = _assetId
		        AND TR.ExecutionID >= _fromExecutionId AND (_toExecutionId IS NULL OR TR.ExecutionID < _toExecutionId)
	)
	SELECT	CreditEntityID
	FROM	Records
	UNION
	SELECT	DebitEntityID
	FROM	Records;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION foundry.TransactionSearch (
	_sourceId INTEGER,
	_fromExecutionId BIGINT, _toExecutionId BIGINT,
	_assetId BIGINT, _entityId BIGINT, _ledgerId BIGINT,
	_transCodes TEXT[],
	_execCodes TEXT[],
	_count INTEGER
	) RETURNS TABLE (
	 ExecutionID BIGINT
	,ExecutionCode TEXT
	,"timestamp" TIMESTAMP WITH TIME ZONE

	,EntryID INTEGER
	,EntryCode TEXT
	,Amount NUMERIC

	,AssetID BIGINT
	,AssetVersion INTEGER
	,DebitLedgerID BIGINT
	,DebitLedgerVersion INTEGER
	,DebitEntityID BIGINT
	,DebitEntityVersion INTEGER
	,DebitBalance NUMERIC
	,CreditLedgerID BIGINT
	,CreditLedgerVersion INTEGER
	,CreditEntityID BIGINT
	,CreditEntityVersion INTEGER
	,CreditBalance NUMERIC
	) AS $$
BEGIN
	RETURN QUERY
	SELECT  EX.ExecutionID, EX.Code, EX.Timestamp, TR.EntryID, TR.Code, TR.Amount,
	        TR.AssetID, TR.AssetVersion,
	        TR.DebitLedgerID, TR.DebitLedgerVersion, TR.DebitEntityID, TR.DebitEntityVersion, TR.DebitBalance,
	        TR.CreditLedgerID, TR.CreditLedgerVersion, TR.CreditEntityID, TR.CreditEntityVersion, TR.CreditBalance
	FROM    foundry.Execution EX
	        JOIN foundry.Transaction TR USING (SourceID, ExecutionID)
	WHERE   EX.SourceID = _sourceId
	        AND EX.ExecutionID >= _fromExecutionId AND (_toExecutionId IS NULL OR EX.ExecutionID < _toExecutionId)
	        AND (_assetId IS NULL OR TR.AssetID = _assetId)
	        AND (_entityId IS NULL OR TR.DebitEntityID = _entityId OR TR.CreditEntityID = _entityId)
	        AND (_ledgerId IS NULL OR TR.DebitLedgerID = _ledgerId OR TR.CreditLedgerID = _ledgerId)
	        AND (_transCodes IS NULL OR TR.Code = ANY(_transCodes))
	        AND (_execCodes IS NULL OR EX.Code = ANY(_execCodes))
	ORDER BY ExecutionID ASC, EntryID ASC
	FETCH FIRST (_count) ROWS ONLY;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMIT TRANSACTION;
