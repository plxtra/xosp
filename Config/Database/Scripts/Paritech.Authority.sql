BEGIN TRANSACTION;
CREATE SCHEMA auth;

CREATE TABLE auth.Asset (
	 AssetID BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL

	,AssetTypeID INTEGER NOT NULL
	,Code TEXT NOT NULL
	,Data JSONB NOT NULL CONSTRAINT DfAssetData DEFAULT '{}'
	
	,CONSTRAINT PkAsset PRIMARY KEY (AssetID)
    ,CONSTRAINT UqAssetAssetTypeCode UNIQUE (AssetTypeID, Code)
);

CREATE TABLE auth.AssetType (
	 AssetTypeID INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL
	 
	,Code TEXT NOT NULL
	,Data JSONB NOT NULL CONSTRAINT DfAssetTypeData DEFAULT '{}'
	
	,CONSTRAINT PkAssetType PRIMARY KEY (AssetTypeID)
    ,CONSTRAINT UqAssetTypeCode UNIQUE (Code)
);

CREATE TABLE auth.Association (
	 ParentAssetID BIGINT NOT NULL
	,ChildAssetID BIGINT NOT NULL
	
	,Data JSONB NOT NULL CONSTRAINT DfAssociationData DEFAULT '{}'
	
	,CONSTRAINT PkAssociation PRIMARY KEY (ParentAssetID, ChildAssetID)
);

ALTER TABLE ONLY auth.Asset
	ADD CONSTRAINT FkAssetAssetType FOREIGN KEY (AssetTypeID) REFERENCES auth.AssetType (AssetTypeID);

ALTER TABLE ONLY auth.Association
	ADD CONSTRAINT FkAssociationChildAsset FOREIGN KEY (ChildAssetID) REFERENCES auth.Asset (AssetID);

ALTER TABLE ONLY auth.Association
	ADD CONSTRAINT FkAssociationParentAsset FOREIGN KEY (ParentAssetID) REFERENCES auth.Asset (AssetID);

CREATE OR REPLACE FUNCTION auth.MergeContext(_baseData JSONB, _updateData JSONB) RETURNS JSONB
LANGUAGE SQL IMMUTABLE SECURITY DEFINER
RETURN jsonb_set(_updateData, '{"Context"}', (
	SELECT	jsonb_agg(COALESCE(Updated.Data, Base.Data))
	FROM	jsonb_array_elements(_baseData->'Context') AS Base (Data)
			FULL JOIN jsonb_array_elements(_updateData->'Context') AS Updated (Data)
			ON Base.Data->>'Application' = Updated.Data->>'Application'
	));

CREATE OR REPLACE FUNCTION auth.AssetGetAll(_apps TEXT[])
	RETURNS TABLE (
	 Code TEXT
	,Type TEXT
	,Data JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	SELECT	ASS.Code, AST.Code, ASS.Data
	FROM	auth.Asset ASS
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	(_apps IS NULL OR jsonb_path_query_array(ASS.Data, '$.Context[*].Application') ?| _apps);
END;

CREATE OR REPLACE FUNCTION auth.AssetGetByCode(_type TEXT, _codes TEXT[], _apps TEXT[])
	RETURNS TABLE (
	 Code TEXT
	,Type TEXT
	,Data JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	SELECT	ASS.Code, AST.Code, ASS.Data
	FROM	auth.Asset ASS
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	AST.Code = _type AND ASS.Code = ANY(_codes)
			AND (_apps IS NULL OR jsonb_path_query_array(ASS.Data, '$.Context[*].Application') ?| _apps);
END;

CREATE OR REPLACE FUNCTION auth.AssetGetByType(_types TEXT[], _apps TEXT[])
	RETURNS TABLE (
	 Code TEXT
	,Type TEXT
	,Data JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	SELECT	ASS.Code, AST.Code, ASS.Data
	FROM	auth.Asset ASS
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	AST.Code = ANY(_types)
			AND (_apps IS NULL OR jsonb_path_query_array(ASS.Data, '$.Context[*].Application') ?| _apps);
END;

CREATE OR REPLACE FUNCTION auth.AssetTypeGetAll()
	RETURNS TABLE (
	 Code TEXT
	,Data JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	SELECT	AST.Code, AST.Data
	FROM	auth.AssetType AST;
END;

CREATE OR REPLACE FUNCTION auth.AssetTypeGetByCode(_codes TEXT[])
	RETURNS TABLE (
	 Code TEXT
	,Data JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	SELECT	AST.Code, AST.Data
	FROM	auth.AssetType AST
	WHERE	Code = ANY (_codes);
END;

CREATE OR REPLACE FUNCTION auth.AssociationGet(_type TEXT, _code TEXT, _totype TEXT, _tocode TEXT)
	RETURNS TABLE (
	 FromCode TEXT
	,FromType TEXT
	,ToCode TEXT
	,ToType TEXT
	,AssetData JSONB
	,AssocData JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	-- Retrieve the data for the root Asset as well
	SELECT	ASS.Code, AST.Code, NULL, NULL, ASS.Data, NULL
	FROM	auth.Asset ASS
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	AST.Code = _type AND ASS.Code = _code
	UNION ALL
	-- Retrieve all the child associations and their assets
	SELECT	_code, _type, ASS.Code, AST.Code, ASS.Data, ASO.Data
	FROM	auth.Association ASO
			JOIN auth.Asset ASS ON ASO.ChildAssetID = ASS.AssetID
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	ASO.ParentAssetID = (SELECT AssetID FROM auth.Asset WHERE Code = _code AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type))
			AND ASO.ChildAssetID = (SELECT AssetID FROM auth.Asset WHERE Code = _tocode AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _totype));
END;

CREATE OR REPLACE FUNCTION auth.AssociationGetFrom(_type TEXT, _code TEXT, _totypes TEXT[], _apps TEXT[])
	RETURNS TABLE (
	 FromCode TEXT
	,FromType TEXT
	,ToCode TEXT
	,ToType TEXT
	,AssetData JSONB
	,AssocData JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	-- Retrieve the data for the root Asset as well
	SELECT	NULL, NULL, ASS.Code, AST.Code, ASS.Data, NULL
	FROM	auth.Asset ASS
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	AST.Code = _type AND ASS.Code = _code
	UNION ALL
	-- Retrieve all the child associations and their assets
	SELECT	_code, _type, ASS.Code, AST.Code, ASS.Data, ASO.Data
	FROM	auth.Association ASO
			JOIN auth.Asset ASS ON ASO.ChildAssetID = ASS.AssetID
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	ASO.ParentAssetID = (SELECT AssetID FROM auth.Asset WHERE Code = _code AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type))
			AND (_totypes IS NULL OR AST.Code = ANY(_totypes))
			-- Optionally filter based on whether the association mentions one of the applications
			AND (_apps IS NULL OR jsonb_path_query_array(ASO.Data, '$.Context[*].Application') ?| _apps);
END;

CREATE OR REPLACE FUNCTION auth.AssociationGetTo(_fromtypes TEXT[], _totype TEXT, _tocode TEXT,  _apps TEXT[])
	RETURNS TABLE (
	 FromCode TEXT
	,FromType TEXT
	,ToCode TEXT
	,ToType TEXT
	,AssetData JSONB
	,AssocData JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	-- Retrieve the data for the root Asset as well
	SELECT	NULL, NULL, ASS.Code, AST.Code, ASS.Data, NULL
	FROM	auth.Asset ASS
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	AST.Code = _totype AND ASS.Code = _tocode
	UNION ALL
	-- Retrieve all associations that reference the root and their assets
	SELECT	ASS.Code, AST.Code, _tocode, _totype, ASS.Data, ASO.Data
	FROM	auth.Association ASO
			JOIN auth.Asset ASS ON ASO.ParentAssetID = ASS.AssetID
			JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
	WHERE	ASO.ChildAssetID = (SELECT AssetID FROM auth.Asset WHERE Code = _tocode AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _totype))
			-- Optionally filter based on the from (parent) types
			AND (_fromtypes IS NULL OR AST.Code = ANY(_fromtypes))
			-- Optionally filter based on whether the association mentions one of the applications
			AND (_apps IS NULL OR jsonb_path_query_array(ASO.Data, '$.Context[*].Application') ?| _apps);
END;

CREATE OR REPLACE FUNCTION auth.AssociationGetTransitive(_type TEXT, _code TEXT, _totypes TEXT[], _apps TEXT[])
	RETURNS TABLE (
	 FromCode TEXT
	,FromType TEXT
	,ToCode TEXT
	,ToType TEXT
	,AssetData JSONB
	,AssocData JSONB
	)
LANGUAGE SQL STABLE SECURITY DEFINER
BEGIN ATOMIC
	WITH RECURSIVE AssetAssociations AS (
		-- Read the root Asset
		SELECT	NULL::BIGINT AS ParentAssetID, ASS.AssetID AS ChildAssetID, NULL::JSONB AS Data
		FROM	auth.Asset ASS
				JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
		WHERE	AST.Code = _type AND ASS.Code = _code
		UNION
		-- Recursively read the associations
		SELECT	ASO.ParentAssetID, ASO.ChildAssetID, ASO.Data
		FROM	AssetAssociations AAS
				JOIN auth.Association ASO ON ASO.ParentAssetID = AAS.ChildAssetID
	)
	SELECT	ASP.Code, ASPT.Code, ASH.Code, ASHT.Code, ASH.Data, AAS.Data
	FROM	AssetAssociations AAS
			LEFT JOIN auth.Asset ASP ON AAS.ParentAssetID = ASP.AssetID
			LEFT JOIN auth.AssetType ASPT ON ASP.AssetTypeID = ASPT.AssetTypeID
			JOIN auth.Asset ASH ON AAS.ChildAssetID = ASH.AssetID
			JOIN auth.AssetType ASHT ON ASH.AssetTypeID = ASHT.AssetTypeID
			-- Optionally filter based on the to-association (cHild) types. Make sure we include the root record
	WHERE	(_totypes IS NULL OR ASPT.Code IS NULL OR ASHT.Code = ANY(_totypes))
			-- Optionally filter based on whether the association mentions one of the applications
			AND (_apps IS NULL OR ASPT.Code IS NULL OR jsonb_path_query_array(AAS.Data, '$.Context[*].Application') ?| _apps);
END;

CREATE OR REPLACE FUNCTION auth.RemoveContext(_baseData JSONB, _apps TEXT[]) RETURNS JSONB
LANGUAGE SQL IMMUTABLE SECURITY DEFINER
RETURN jsonb_set_lax(_baseData, '{"Context"}', (
	SELECT	jsonb_agg(Base.Data)
	FROM	jsonb_array_elements(_baseData->'Context') AS Base (Data)
	WHERE	Base.Data->>'Application' != ANY (_apps)
	), FALSE, 'delete_key');

CREATE OR REPLACE PROCEDURE auth.AssetDelete(_type TEXT, _codes TEXT[], _apps TEXT[], _delete BOOLEAN) AS $$
BEGIN
	IF _apps IS NULL THEN
		-- No application filter, so we're just deleting every match
		DELETE
		FROM	auth.Asset ASS
		WHERE	ASS.AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type) AND ASS.Code = ANY (_codes);
	ELSIF _delete = TRUE THEN
		-- Application filter supplied, remove matching applications from the data context, and remove affected Assets that no longer have any context
		MERGE INTO auth.Asset AS ASS
		USING (
			SELECT	AssetID, auth.RemoveContext(ASS.Data, _apps) AS Data
			FROM	auth.Asset ASS
			WHERE	ASS.AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type) AND ASS.Code = ANY (_codes)
		) AS InData ON ASS.AssetID = InData.AssetID
		WHEN MATCHED AND jsonb_array_length(InData.Data->'Context') > 0 THEN
			UPDATE SET Data = InData.Data
		-- If we don't check the original context data, then the Assets will be deleted when empty, even if we didn't remove anything
		WHEN MATCHED AND jsonb_array_length(ASS.Data->'Context') > 0 THEN
			DELETE;
	ELSE
		-- Application filter supplied, but no delete, so we're just removing the app contexts
		UPDATE	auth.Asset AS ASS
		SET		Data = auth.RemoveContext(Data, _apps)
		WHERE	ASS.AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type) AND ASS.Code = ANY (_codes);
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE PROCEDURE auth.AssetEnsure(_types TEXT[], _codes TEXT[], _data JSONB[])
LANGUAGE SQL SECURITY DEFINER
BEGIN ATOMIC
	INSERT INTO auth.Asset AS ASS (AssetTypeID, Code, Data)
		SELECT	AST.AssetTypeID, InData.Code, InData.Data
		FROM	unnest(_types, _codes, _data) AS InData (Type, Code, Data)
				LEFT JOIN auth.AssetType AST ON AST.Code = InData.Type -- Left join so we try to insert nulls and fail if a given type is invalid
		ON CONFLICT (AssetTypeID, Code) DO UPDATE
		SET Data = auth.MergeContext(ASS.Data, EXCLUDED.Data)
		WHERE jsonb_array_length(EXCLUDED.Data->'Context') > 0;
END;

CREATE OR REPLACE PROCEDURE auth.AssetReplace(_type TEXT, _code TEXT, _newtype TEXT, _newcode TEXT, _data JSONB)
LANGUAGE SQL SECURITY DEFINER
BEGIN ATOMIC
	UPDATE	auth.Asset AS ASS
	SET		AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _newtype),
			Code = _newcode,
			Data = _data
	WHERE	ASS.AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type) AND ASS.Code = _code;
END;

CREATE OR REPLACE PROCEDURE auth.AssetTypeDelete(_codes TEXT[])
LANGUAGE SQL SECURITY DEFINER
BEGIN ATOMIC
	DELETE
	FROM	auth.AssetType
	WHERE	Code = ANY (_codes);
END;

CREATE OR REPLACE PROCEDURE auth.AssetTypeEnsure(_codes TEXT[], _data JSONB[])
LANGUAGE SQL SECURITY DEFINER
BEGIN ATOMIC
	INSERT INTO auth.AssetType (Code, Data)
		SELECT	InData.Code, InData.Data
		FROM	unnest(_codes, _data) AS InData (Code, Data)
		ON CONFLICT (Code) DO UPDATE
		SET Data = EXCLUDED.Data;
END;

CREATE OR REPLACE PROCEDURE auth.AssetTypeReplace(_code TEXT, _newcode TEXT, _data JSONB)
LANGUAGE SQL SECURITY DEFINER
BEGIN ATOMIC
	UPDATE	auth.AssetType AS AST
	SET		Code = _newcode,
			Data = _data
	WHERE	AST.Code = _code;
END;

CREATE OR REPLACE PROCEDURE auth.AssociationDelete(_type TEXT, _code TEXT, _totype TEXT, _tocode TEXT, _apps TEXT[], _delete BOOLEAN) AS $$
DECLARE
	_parentassetid BIGINT;
	_childassetid BIGINT;
BEGIN
	SELECT	AssetID INTO _parentassetid
	FROM	auth.Asset
	WHERE	Code = _code AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type);

	SELECT	AssetID INTO _childassetid
	FROM	auth.Asset
	WHERE	Code = _tocode AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _totype);

	IF _apps IS NULL THEN
		-- No application filter, so we're just deleting any match
		DELETE
		FROM	auth.Association ASO
		WHERE	ASO.ParentAssetID = _parentassetid AND ASO.ChildAssetID = _childassetid;
	ELSIF _delete IS TRUE THEN
		-- Application filter supplied, remove all applications from the data context, and remove the association entirely if it no longer has any context
		MERGE INTO auth.Association AS ASO
		USING (
			SELECT	ASO.ParentAssetID, ASO.ChildAssetID, auth.RemoveContext(ASO.Data, _apps) AS Data
			FROM	auth.Association ASO
			WHERE	ASO.ParentAssetID = _parentassetid AND ASO.ChildAssetID = _childassetid
		) AS InData ON ASO.ParentAssetID = InData.ParentAssetID AND ASO.ChildAssetID = InData.ChildAssetID
		WHEN MATCHED AND jsonb_array_length(InData.Data->'Context') > 0 THEN
			UPDATE SET Data = InData.Data
		-- If we don't check the original context data, then the Assets will be deleted when empty, even if we didn't remove anything
		WHEN MATCHED AND jsonb_array_length(ASO.Data->'Context') > 0 THEN
			DELETE;
	ELSE
		-- Application filter supplied, but no delete, so we're just removing the app contexts
		UPDATE	auth.Association AS ASO
		SET		Data = auth.RemoveContext(Data, _apps)
		WHERE	ASO.ParentAssetID = _parentassetid AND ASO.ChildAssetID = _childassetid;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE PROCEDURE auth.AssociationDeleteAll(_type TEXT, _code TEXT, _apps TEXT[], _delete BOOLEAN) AS $$
DECLARE
	_parentassetid BIGINT;
BEGIN
	SELECT	AssetID INTO _parentassetid
	FROM	auth.Asset
	WHERE	Code = _code AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type);

	IF _apps IS NULL THEN
		-- No application filter, so we're just deleting any matches
		DELETE
		FROM	auth.Association ASO
		WHERE	ASO.ParentAssetID = _parentassetid;
	ELSIF _delete = TRUE THEN
		-- Application filter supplied, remove all applications from the data context, and remove the associations entirely if they no longer have any context
		MERGE INTO auth.Association AS ASO
		USING (
			SELECT	ASO.ParentAssetID, ASO.ChildAssetID, auth.RemoveContext(ASO.Data, _apps) AS Data
			FROM	auth.Association ASO
			WHERE	_parentassetid
		) AS InData ON ASO.ParentAssetID = InData.ParentAssetID AND ASO.ChildAssetID = InData.ChildAssetID
		WHEN MATCHED AND jsonb_array_length(InData.Data->'Context') > 0 THEN
			UPDATE SET Data = InData.Data
		WHEN MATCHED AND jsonb_array_length(ASO.Data->'Context') > 0 THEN
			DELETE;
	ELSE
		-- Application filter supplied, but no delete, so we're just removing the app contexts
		UPDATE	auth.Association AS ASO
		SET		Data = auth.RemoveContext(Data, _apps)
		WHERE	_parentassetid;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE PROCEDURE auth.AssociationDeleteByType(_type TEXT, _code TEXT, _totypes TEXT[], _apps TEXT[], _delete BOOLEAN) AS $$
DECLARE
	_parentassetid BIGINT;
BEGIN
	SELECT	AssetID INTO _parentassetid
	FROM	auth.Asset
	WHERE	Code = _code AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type);

	IF _apps IS NULL THEN
		-- No application filter, so we're just deleting any matches
		DELETE
		FROM	auth.Association ASO
		USING	auth.Asset ASS
				JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
		WHERE	ASO.ParentAssetID = _parentassetid
				AND ASO.ChildAssetID = ASS.AssetID AND AST.Code = ANY(_totypes);
	ELSIF _delete = TRUE THEN
		-- Application filter supplied, remove all applications from the data context, and remove the associations entirely if they no longer have any context
		MERGE INTO auth.Association AS ASO
		USING (
			SELECT	ASO.ParentAssetID, ASO.ChildAssetID, auth.RemoveContext(ASO.Data, _apps) AS Data
			FROM	auth.Association ASO
					JOIN auth.Asset ASS ON ASO.ChildAssetID = ASS.AssetID
					JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
			WHERE	ASO.ParentAssetID = _parentassetid
					AND AST.Code = ANY(_totypes)
		) AS InData ON ASO.ParentAssetID = InData.ParentAssetID AND ASO.ChildAssetID = InData.ChildAssetID
		WHEN MATCHED AND jsonb_array_length(InData.Data->'Context') > 0 THEN
			UPDATE SET Data = InData.Data
		-- If we don't check the original context data, then the Assets will be deleted when empty, even if we didn't remove anything
		WHEN MATCHED AND jsonb_array_length(ASO.Data->'Context') > 0 THEN
			DELETE;
	ELSE
		-- Application filter supplied, but no delete, so we're just removing the app contexts
		UPDATE	auth.Association AS ASO
		SET		Data = auth.RemoveContext(Data, _apps)
		FROM	auth.Asset ASS
				JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID
		WHERE	ASO.ParentAssetID = _parentassetid
				AND ASO.ChildAssetID = ASS.AssetID AND AST.Code = ANY(_totypes);
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE PROCEDURE auth.AssociationEnsure(_type TEXT, _code TEXT, _data JSONB, _totypes TEXT[], _tocodes TEXT[], _toassetdata JSONB[], _assocdata JSONB[])
LANGUAGE SQL SECURITY DEFINER
BEGIN ATOMIC
	-- We add or merge any referenced Assets
	INSERT INTO auth.Asset AS ASS (AssetTypeID, Code, Data)
		SELECT	AST.AssetTypeID, InData.Code, InData.Data
		FROM	unnest(_totypes, _tocodes, _toassetdata) AS InData (Type, Code, Data)
				LEFT JOIN auth.AssetType AST ON AST.Code = InData.Type  -- Left join so we try to insert nulls and fail if a given type is invalid
		UNION	
		SELECT	(SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type), _code, _data -- Same here, try to insert a null and fail
		ON CONFLICT (AssetTypeID, Code) DO UPDATE
		SET Data = auth.MergeContext(ASS.Data, EXCLUDED.Data)
		WHERE jsonb_array_length(EXCLUDED.Data->'Context') > 0;

	-- Now we can attach or update the Associations
	INSERT INTO auth.Association AS ASO (ParentAssetID, ChildAssetID, Data)
		SELECT	(SELECT AssetID FROM auth.Asset WHERE AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type) AND Code = _code),
				ASS.AssetID, InData.Data
		FROM	unnest(_totypes, _tocodes, _assocdata) AS InData (Type, Code, Data)
				JOIN auth.Asset ASS ON ASS.Code = InData.Code
				JOIN auth.AssetType AST ON ASS.AssetTypeID = AST.AssetTypeID AND AST.Code = InData.Type
		ON CONFLICT (ParentAssetID, ChildAssetID) DO UPDATE
		SET Data = auth.MergeContext(ASO.Data, EXCLUDED.Data)
		WHERE jsonb_array_length(EXCLUDED.Data->'Context') > 0;
END;

CREATE OR REPLACE PROCEDURE auth.AssociationSync(_type TEXT, _code TEXT, _data JSONB, _totype TEXT, _tocodes TEXT[], _toassetdata JSONB[], _assocdata JSONB[], _apps TEXT[], _delete BOOLEAN) AS $$
DECLARE
	_assetid BIGINT;
	_assettypeID INTEGER;
BEGIN
	SELECT	AssetTypeID INTO _assettypeid
	FROM	auth.AssetType
	WHERE	Code = _totype;

	-- We add or merge any referenced Assets
	INSERT INTO auth.Asset AS ASS (AssetTypeID, Code, Data)
		SELECT	_assettypeid, InData.Code, InData.Data
		FROM	unnest(_tocodes, _toassetdata) AS InData (Code, Data)
		UNION
		SELECT	(SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type), _code, _data -- Try to insert a null and fail if the type is invalid
		ON CONFLICT (AssetTypeID, Code) DO UPDATE
		SET Data = auth.MergeContext(ASS.Data, EXCLUDED.Data)
		-- Only need to merge context when we're trying to actually insert some context
		WHERE jsonb_array_length(EXCLUDED.Data->'Context') > 0;

	SELECT	AssetID INTO _assetid
	FROM	auth.Asset
	WHERE	Code = _code AND AssetTypeID = (SELECT AssetTypeID FROM auth.AssetType WHERE Code = _type);

	IF _apps IS NULL THEN
		MERGE INTO auth.Association AS ASO
		USING (
				-- Lookup the Assets for all the codes mentioned in the synchronise, and merge the contexts with the existing data
				SELECT	ASS.AssetID, auth.MergeContext(ASS.Data, ToData.Data)
				FROM	unnest(_tocodes, _assocdata) AS ToData (Code, Data)
						JOIN auth.Asset ASS ON ToData.Code = ASS.Code
				WHERE	ASS.AssetTypeID = _assettypeid
				UNION
				-- Lookup the Assets with associations that are NOT mentioned in the synchronise. We'll delete these
				SELECT	ASO.ChildAssetID, NULL
				FROM	auth.Association ASO
						JOIN auth.Asset ASS ON ASO.ChildAssetID = ASS.AssetID
				WHERE	ASO.ParentAssetID = _assetid AND ASS.AssetTypeID = _assettypeid
						AND ASS.Code != ALL(_tocodes)
		) AS InData (ChildAssetID, Data) ON ASO.ParentAssetID = _assetid AND ASO.ChildAssetID = InData.ChildAssetID
		WHEN MATCHED AND InData.Data IS NOT NULL THEN
			UPDATE SET Data = InData.Data
		WHEN MATCHED THEN
			DELETE
		WHEN NOT MATCHED THEN
			INSERT (ParentAssetID, ChildAssetID, Data)
			VALUES (_assetid, InData.ChildAssetID, InData.Data);
	ELSIF _delete IS TRUE THEN
		MERGE INTO auth.Association AS ASO
		USING (
				-- Lookup the Assets for all the codes mentioned in the synchronise, and merge the contexts with the existing data
				SELECT	ASS.AssetID, auth.MergeContext(ASS.Data, ToData.Data), TRUE -- We flag this, so if there's no context, we don't delete it
				FROM	unnest(_tocodes, _assocdata) AS ToData (Code, Data)
						JOIN auth.Asset ASS ON ToData.Code = ASS.Code
				WHERE	ASS.AssetTypeID = _assettypeid
				UNION
				-- Lookup the Assets with associations that are NOT mentioned in the synchronise
				SELECT	ASO.ChildAssetID, auth.RemoveContext(ASO.Data, _apps), FALSE
				FROM	auth.Association ASO
						JOIN auth.Asset ASS ON ASO.ChildAssetID = ASS.AssetID
				WHERE	ASO.ParentAssetID = _assetid AND ASS.AssetTypeID = _assettypeid
						AND ASS.Code != ALL(_tocodes)
		) AS InData (ChildAssetID, Data, ToKeep) ON ASO.ParentAssetID = _assetid AND ASO.ChildAssetID = InData.ChildAssetID
		-- We want to update any merged records, and any records where we deleted some (but not all) context data
		WHEN MATCHED AND (InData.ToKeep OR jsonb_array_length(InData.Data->'Context') > 0) THEN
			UPDATE SET Data = InData.Data
		-- Matches that we're not inserting and that we removed all context from need to be deleted
		WHEN MATCHED AND jsonb_array_length(ASO.Data->'Context') > 0 THEN
			DELETE
		-- Records that don't match need to be inserted
		WHEN NOT MATCHED THEN
			INSERT (ParentAssetID, ChildAssetID, Data)
			VALUES (_assetid, InData.ChildAssetID, InData.Data);
	ELSE
		MERGE INTO auth.Association AS ASO
		USING (
				-- Lookup the Assets for all the codes mentioned in the synchronise, and merge the contexts with the existing data
				SELECT	ASS.AssetID, auth.MergeContext(ASS.Data, ToData.Data)
				FROM	unnest(_tocodes, _assocdata) AS ToData (Code, Data)
						JOIN auth.Asset ASS ON ToData.Code = ASS.Code
				WHERE	ASS.AssetTypeID = _assettypeid
				UNION
				-- Lookup the Assets with associations that are NOT mentioned in the synchronise
				SELECT	ASO.ChildAssetID, auth.RemoveContext(ASO.Data, _apps)
				FROM	auth.Association ASO
						JOIN auth.Asset ASS ON ASO.ChildAssetID = ASS.AssetID
				WHERE	ASO.ParentAssetID = _assetid AND ASS.AssetTypeID = _assettypeid
						AND ASS.Code != ALL(_tocodes)
		) AS InData (ChildAssetID, Data) ON ASO.ParentAssetID = _assetid AND ASO.ChildAssetID = InData.ChildAssetID
		WHEN MATCHED THEN
			UPDATE SET Data = InData.Data
		WHEN NOT MATCHED THEN
			INSERT (ParentAssetID, ChildAssetID, Data)
			VALUES (_assetid, InData.ChildAssetID, InData.Data);
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMIT TRANSACTION;
